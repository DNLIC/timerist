<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <title>Mobility Timer - Timerist | Mobility Workout Timer, Multi-Activity Timer</title>
    <meta name="description" content="Mobility workout timer for complex multi-activity workouts. Create time-based and rep-based activities with round groups, rest periods, and more.">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        .hidden { display: none; }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        :root {
            --background: 245 247 250;
            --foreground: 51 51 51;
            --card: 255 255 255;
            --card-foreground: 51 51 51;
            --primary: 74 144 226;
            --primary-foreground: 255 255 255;
            --secondary: 80 200 120;
            --secondary-foreground: 255 255 255;
            --muted: 102 102 102;
            --muted-foreground: 153 153 153;
            --accent: 225 232 237;
            --accent-foreground: 51 51 51;
            --destructive: 231 76 60;
            --destructive-foreground: 255 255 255;
            --border: 225 232 237;
            --input: 225 232 237;
            --ring: 74 144 226;
            --radius: 0.5rem;
        }
        
        [data-theme="style1"] {
            --background: 0 0 0;
            --foreground: 255 255 255;
            --card: 26 26 26;
            --card-foreground: 255 255 255;
            --primary: 255 0 0;
            --primary-foreground: 255 255 255;
            --secondary: 0 255 0;
            --secondary-foreground: 0 0 0;
            --muted: 204 204 204;
            --muted-foreground: 153 153 153;
            --accent: 51 51 51;
            --accent-foreground: 255 255 255;
            --destructive: 255 0 0;
            --destructive-foreground: 255 255 255;
            --border: 51 51 51;
            --input: 51 51 51;
            --ring: 255 0 0;
        }
        
        body {
            background: rgb(var(--background));
            color: rgb(var(--foreground));
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        * {
            box-sizing: border-box;
        }
        
        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            max-width: 1200px;
            padding: 1rem;
            padding-bottom: env(safe-area-inset-bottom, 1rem);
            margin: 0 auto;
            overflow-x: hidden;
            position: relative;
        }
        
        .timer-container {
            max-width: 1000px;
            margin: 0 auto;
            overflow-x: hidden;
            margin-top: clamp(4rem, 8vw, 5rem);
            width: 100%;
        }
        
        @media (min-width: 768px) and (max-width: 1024px) and (orientation: portrait) {
            .timer-container {
                margin-top: clamp(4rem, 6vw, 5rem);
            }
        }
        
        @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
            .timer-container {
                margin-top: clamp(4.5rem, 7vw, 5.5rem);
            }
        }
        
        @media (min-width: 1025px) {
            .timer-container {
                margin-top: clamp(4rem, 6vw, 5rem);
            }
        }
        
        .bg-card { background-color: rgb(var(--card)); }
        .text-foreground { color: rgb(var(--foreground)); }
        .text-muted-foreground { color: rgb(var(--muted-foreground)); }
        .bg-primary { background-color: rgb(var(--primary)); }
        .text-primary-foreground { color: rgb(var(--primary-foreground)); }
        .bg-secondary { background-color: rgb(var(--secondary)); }
        .text-secondary-foreground { color: rgb(var(--secondary-foreground)); }
        .bg-destructive { background-color: rgb(var(--destructive)); }
        .text-destructive-foreground { color: rgb(var(--destructive-foreground)); }
        .border-border { border-color: rgb(var(--border)); }
        .hover\:bg-primary\/90:hover { background-color: rgba(var(--primary), 0.9); }
        .hover\:bg-secondary\/90:hover { background-color: rgba(var(--secondary), 0.9); }
        
        .timer-display-large {
            font-size: 4rem;
            font-weight: 700;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-variant-numeric: tabular-nums;
            line-height: 1;
            letter-spacing: -0.02em;
            color: rgb(var(--primary));
            transition: color 0.3s ease;
            margin-bottom: 1rem;
            word-break: keep-all;
            overflow-wrap: normal;
        }
        
        @media (min-width: 390px) {
            .timer-display-large {
                font-size: 5rem;
            }
        }
        
        @media (min-width: 768px) {
            .timer-display-large {
                font-size: 8rem;
            }
        }
        
        .timer-display-large.warning {
            color: #f59e0b;
        }
        
        .timer-display-large.danger {
            color: rgb(var(--destructive));
        }
        
        .timer-display-block {
            padding: 1.5rem;
            overflow: hidden;
            box-sizing: border-box;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            border-radius: 1rem;
        }
        
        @media (min-width: 640px) {
            .timer-display-block {
                padding: 2rem;
            }
        }
        
        @media (min-width: 768px) {
            .timer-display-block {
                padding: 2rem;
            }
        }
        
        .phase-label {
            font-size: 1.25rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            color: rgb(var(--primary));
            transition: color 0.3s ease;
        }
        
        @media (min-width: 768px) {
            .phase-label {
                font-size: 1.5rem;
            }
        }
        
        .phase-label.rest {
            color: rgb(var(--secondary));
        }
        
        .round-info {
            font-size: 0.875rem;
            color: rgb(var(--muted-foreground));
            margin-top: 0.75rem;
        }
        
        @media (min-width: 768px) {
            .round-info {
                font-size: 1rem;
            }
        }
        
        .status-line {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: rgb(var(--muted-foreground));
            margin-bottom: 0.5rem;
        }
        
        .workout-title {
            font-weight: 600;
            color: rgb(var(--foreground));
        }
        
        .control-btn {
            padding: 0.75rem 1.25rem;
            border-radius: 1rem;
            font-size: 1rem;
            font-weight: 500;
            min-height: 56px;
            min-width: 56px;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
            font-family: inherit;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            white-space: nowrap;
            flex: 1 1 0;
            min-width: 0;
            text-align: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        /* Narrow viewport: smaller buttons so 3 across fit; 2Ã—2 only when 4 buttons visible (class added by JS) */
        @media (max-width: 430px) {
            .control-buttons-container {
                flex-wrap: nowrap;
                gap: 0.5rem;
            }
            .control-btn {
                flex: 1 1 0;
                min-width: 0;
                padding: 0.5rem 0.375rem;
                font-size: 0.8125rem;
                min-height: 48px;
                border-radius: 0.75rem;
                text-align: center;
            }
            /* When exactly 4 buttons visible: two rows of two (no hanging button) */
            .control-buttons-container.four-buttons {
                flex-wrap: wrap;
            }
            .control-buttons-container.four-buttons .control-btn {
                flex: 1 1 calc(50% - 0.25rem);
                min-width: calc(50% - 0.25rem);
            }
        }
        @media (max-width: 390px) {
            .control-btn { min-height: 44px; border-radius: 0.75rem; font-size: 0.75rem; padding: 0.45rem 0.25rem; }
            .control-buttons-container:not(.four-buttons) .control-btn { min-width: 0; }
            .control-buttons-container.four-buttons .control-btn { min-width: calc(50% - 0.25rem); padding: 0.45rem 0.25rem; }
        }
        /* Allow card and container to shrink so buttons wrap instead of overflowing */
        .control-buttons-card {
            min-width: 0;
            width: 100%;
            box-sizing: border-box;
        }
        /* iOS sound banner: two buttons same cushion as Set Up / Clear */
        .ios-sound-banner-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            width: 100%;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }
        .ios-sound-banner-buttons .control-btn {
            flex: 1 1 0;
            min-width: 0;
        }
        @media (min-width: 390px) {
            .ios-sound-banner-buttons { gap: 0.75rem; }
        }
        @media (min-width: 640px) {
            .ios-sound-banner-buttons { gap: 1rem; }
        }
        .control-buttons-container {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            width: 100%;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        @media (min-width: 390px) {
            .control-buttons-container {
                gap: 0.75rem;
            }
        }
        
        @media (min-width: 640px) {
            .control-buttons-container {
                gap: 1rem;
            }
        }
        
        @media (min-width: 431px) {
            .control-buttons-container {
                flex-wrap: nowrap;
            }
            .control-btn {
                min-width: 0;
            }
        }
        
        .control-btn.btn-primary {
            background-color: rgb(var(--primary));
            color: rgb(var(--primary-foreground));
        }
        
        .control-btn.btn-primary:hover:not(:disabled) {
            background-color: rgba(var(--primary), 0.9);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        #setupBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #setupBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        .control-btn.btn-primary.paused,
        .control-btn.btn-primary.paused:hover,
        .control-btn.btn-primary.paused:active,
        .control-btn.btn-primary.paused:focus {
            background-color: rgb(100, 100, 100) !important;
            color: rgb(255, 255, 255) !important;
        }
        
        [data-theme="style1"] .control-btn.btn-primary.paused,
        [data-theme="style1"] .control-btn.btn-primary.paused:hover,
        [data-theme="style1"] .control-btn.btn-primary.paused:active,
        [data-theme="style1"] .control-btn.btn-primary.paused:focus {
            background-color: rgb(150, 150, 150) !important;
            color: rgb(0, 0, 0) !important;
        }
        
        .control-btn.btn-secondary {
            background-color: rgb(var(--secondary));
            color: rgb(var(--secondary-foreground));
        }
        
        .control-btn.btn-secondary:hover:not(:disabled) {
            background-color: rgba(var(--secondary), 0.9);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        #clearBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #clearBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        #repeatWorkoutBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #repeatWorkoutBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        #startBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #startBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        #pauseBtn:hover:not(:disabled):not(.paused) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #pauseBtn:hover:not(:disabled):not(.paused) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        .control-btn.btn-destructive {
            background-color: rgb(var(--destructive));
            color: rgb(var(--destructive-foreground));
        }
        
        .control-btn.btn-destructive:hover:not(:disabled) {
            background-color: rgba(var(--destructive), 0.9);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        #resetBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #resetBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        /* Export button hover - dark gray */
        #exportBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #exportBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        /* Import button hover - dark gray */
        #importBtn:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] #importBtn:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .hamburger-menu {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgb(var(--foreground));
            font-size: 1.5rem;
            transition: opacity 0.2s;
            width: 44px;
            height: 44px;
            border-radius: var(--radius);
            flex-shrink: 0;
        }
        
        .hamburger-menu:hover {
            opacity: 0.7;
        }
        
        .sheet-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1001;
        }
        .sheet-overlay.open { opacity: 1; visibility: visible; }
        .bottom-sheet {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            max-width: 100%;
            max-height: 85vh;
            background: rgb(var(--card));
            border-radius: 1.5rem 1.5rem 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom, 0);
            box-sizing: border-box;
        }
        .bottom-sheet.open { transform: translateY(0); }
        .sheet-grabber {
            width: 40px;
            height: 4px;
            background: rgb(var(--muted-foreground));
            border-radius: 2px;
            margin: 0.75rem auto;
            opacity: 0.5;
            flex-shrink: 0;
        }
        .sheet-header {
            padding: 0 1.5rem 1rem;
            padding-left: max(1.5rem, env(safe-area-inset-left));
            padding-right: max(1.5rem, env(safe-area-inset-right));
            border-bottom: 1px solid rgb(var(--border));
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .sheet-content {
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 1rem 1.5rem 2rem;
            padding-left: max(1.5rem, env(safe-area-inset-left));
            padding-right: max(1.5rem, env(safe-area-inset-right));
            flex: 1;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
        }
        .sheet-section { margin-bottom: 1.5rem; }
        .sheet-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgb(var(--muted-foreground));
            margin-bottom: 0.75rem;
        }
        .sheet-section p {
            color: rgb(var(--muted-foreground));
            line-height: 1.6;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
        }
        .sheet-header-actions { display: flex; align-items: center; gap: 0.5rem; }
        .header-clear-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: rgb(var(--destructive));
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
        }
        .header-clear-btn:hover { opacity: 0.8; }
        .drawer-close {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: rgb(var(--foreground));
            padding: 0.25rem;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
        }
        .drawer-close:hover { opacity: 0.7; }
        .btn-clear-all-settings {
            width: 100%;
            min-height: 52px;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            border: 2px solid rgb(var(--destructive));
            background: rgb(var(--destructive));
            color: rgb(var(--destructive-foreground));
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            font-family: inherit;
            transition: opacity 0.2s;
        }
        .btn-clear-all-settings:hover { opacity: 0.9; }
        
        .input-group {
            margin-bottom: 1.5rem;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: rgb(var(--muted-foreground));
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid rgb(var(--input));
            border-radius: 0.75rem;
            background-color: rgb(var(--background));
            color: rgb(var(--foreground));
            font-size: 16px;
            min-height: 52px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: rgb(var(--ring));
            box-shadow: 0 0 0 3px rgba(var(--ring), 0.2);
        }
        .shadcn-input, .shadcn-textarea {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid rgb(var(--input));
            border-radius: 0.75rem;
            background: rgb(var(--background));
            color: rgb(var(--foreground));
            font-size: 16px;
            min-height: 52px;
            font-family: inherit;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .shadcn-textarea { min-height: 100px; resize: vertical; }
        .shadcn-input:focus, .shadcn-textarea:focus {
            outline: none;
            border-color: rgb(var(--ring));
            box-shadow: 0 0 0 3px rgba(var(--ring), 0.2);
        }
        .workout-select {
            width: 100%;
            padding: 0.875rem 2.5rem 0.875rem 1rem;
            border-radius: 0.75rem;
            font-size: 16px;
            font-weight: 500;
            border: 2px solid rgb(var(--input));
            background-color: rgb(var(--background));
            color: rgb(var(--foreground));
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25rem;
            min-height: 52px;
        }
        .workout-select:hover:not(:disabled) { border-color: rgb(var(--ring)); }
        .workout-select:focus {
            outline: none;
            border-color: rgb(var(--ring));
            box-shadow: 0 0 0 3px rgba(var(--ring), 0.2);
        }
        .workout-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: rgb(var(--muted));
        }
        [data-theme="style1"] .workout-select {
            background-color: rgb(var(--card));
            border-color: rgb(var(--border));
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23fafafa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
        }
        [data-theme="style1"] .workout-select:focus { border-color: rgb(var(--ring)); }
        .input-group textarea { min-height: 100px; resize: vertical; }
        .input-group label { text-align: left; }
        .sheet-section h3 { text-align: left; }
        /* Thick slider + stepper (interval-style): left-justified labels, round entry box */
        .custom-time-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid rgb(var(--input));
            border-radius: 0.75rem;
            background: rgb(var(--background));
            color: rgb(var(--foreground));
            font-size: 16px;
            min-height: 52px;
            font-family: inherit;
            text-align: center;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .custom-time-input:focus {
            outline: none;
            border-color: rgb(var(--ring));
            box-shadow: 0 0 0 3px rgba(var(--ring), 0.2);
        }
        .round-group-card .custom-time-input { background: rgb(var(--card)); color: rgb(var(--card-foreground)); }
        .time-slider-wrap { margin-top: 0.5rem; margin-bottom: 0.25rem; }
        .time-slider-wrap input[type="range"] {
            width: 100%;
            height: 52px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        .time-slider-wrap input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 16px;
            border-radius: 8px;
            background: rgb(var(--input));
            cursor: pointer;
        }
        .time-slider-wrap input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            margin-top: -12px;
            border-radius: 50%;
            background: rgb(var(--primary));
            border: 3px solid rgb(var(--card));
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        .time-slider-wrap input[type="range"]::-moz-range-track {
            width: 100%;
            height: 16px;
            border-radius: 8px;
            background: rgb(var(--input));
            cursor: pointer;
        }
        .time-slider-wrap input[type="range"]::-moz-range-thumb {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgb(var(--primary));
            border: 3px solid rgb(var(--card));
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        .time-stepper-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.5rem;
        }
        .stepper-btn {
            min-width: 56px;
            min-height: 56px;
            border-radius: 1rem;
            border: 2px solid rgb(var(--border));
            background: rgb(var(--card));
            color: rgb(var(--foreground));
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            flex-shrink: 0;
        }
        .stepper-btn:hover:not(:disabled) { background: rgb(var(--accent)); }
        .stepper-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .time-stepper-row .custom-time-input { flex: 1; min-width: 0; }
        .rounds-stepper {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }
        .rounds-stepper .stepper-btn { min-width: 64px; min-height: 64px; font-size: 1.5rem; }
        .rounds-stepper .custom-time-input { max-width: 100px; }
        .rounds-adjust-btn { min-width: 48px; min-height: 48px; font-size: 1.25rem; }
        
        /* Activity card: min-width 0 and input shrink for vertical iPhone (Section 13) */
        .activity-card {
            background-color: rgb(var(--card));
            border: 1px solid rgb(var(--border));
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            min-width: 0;
        }
        .activity-card input[type="text"] {
            min-width: 0;
            box-sizing: border-box;
        }
        .activities-container {
            min-width: 0;
        }
        
        .round-group-card {
            background-color: rgba(var(--accent), 0.3);
            border: 2px solid rgb(var(--border));
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .round-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .round-group-name {
            font-weight: 600;
            font-size: 1rem;
            color: rgb(var(--foreground));
        }
        
        /* Round group card inputs: theme-aware background so text is visible in dark mode */
        .round-group-card input,
        .round-group-card select,
        .round-group-card textarea {
            background-color: rgb(var(--card));
            color: rgb(var(--card-foreground));
            border: 2px solid rgb(var(--input));
            border-radius: var(--radius);
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-family: inherit;
        }
        .round-group-card input:focus,
        .round-group-card select:focus,
        .round-group-card textarea:focus {
            outline: none;
            border-color: rgb(var(--ring));
            box-shadow: 0 0 0 2px rgba(var(--ring), 0.2);
        }
        
        .btn-add {
            background-color: rgb(var(--primary));
            color: rgb(var(--primary-foreground));
            border: none;
            border-radius: var(--radius);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-add:hover:not(:disabled) {
            background-color: rgb(100, 100, 100);
            color: rgb(255, 255, 255);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        [data-theme="style1"] .btn-add:hover:not(:disabled) {
            background-color: rgb(150, 150, 150);
            color: rgb(0, 0, 0);
        }
        
        .btn-add:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-remove {
            background-color: rgb(var(--destructive));
            color: rgb(var(--destructive-foreground));
            border: none;
            border-radius: var(--radius);
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-remove:hover {
            background-color: rgba(var(--destructive), 0.9);
        }
        
        .workout-steps-container {
            margin-top: 1.5rem;
            border: 1px solid rgb(var(--border));
            border-radius: var(--radius);
            background-color: rgb(var(--card));
        }
        
        .workout-steps-list {
            padding: 0.75rem;
        }
        
        .workout-step-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgb(var(--border));
            color: rgb(var(--foreground));
            font-size: 0.875rem;
        }
        
        .workout-step-item:last-child {
            border-bottom: none;
        }
        
        .workout-step-header {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .workout-step-details {
            font-size: 0.75rem;
            color: rgb(var(--muted-foreground));
        }
        
        .header-top {
            position: absolute;
            top: clamp(1rem, 3vw, 2rem);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 clamp(1rem, 3vw, 2rem);
            z-index: 10;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            gap: 0.5rem;
            min-width: 0;
        }
        .header-top > div:first-child {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 0;
            flex-shrink: 1;
            overflow: hidden;
        }
        @media (max-width: 390px) {
            .header-top { padding: 0 0.75rem; }
            .header-top > div:first-child { gap: 0.5rem; }
            .header-top .separator, .header-top > div:first-child > a:nth-of-type(2) { display: none; }
            .header-top > div:first-child > span:last-of-type { font-size: 0.875rem !important; }
            #timerist-logo { width: 36px !important; height: 36px !important; flex-shrink: 0; }
        }
        @media (min-width: 391px) and (max-width: 428px) {
            .header-top { padding: 0 1rem; }
            .header-top .separator { display: none; }
            .header-top > div:first-child > span { font-size: 0.875rem !important; }
        }
        
        @media (min-width: 640px) {
            .container {
                padding: 2rem;
            }
        }
        
        @media (min-width: 768px) {
            .container {
                padding: 2rem 3rem;
            }
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
            min-width: fit-content;
        }
        
        @media (max-width: 428px) {
            .header-actions {
                gap: 0.375rem;
            }
            
            .header-actions .mode-toggle-btn,
            .header-actions .hamburger-menu {
                width: 40px;
                height: 40px;
                padding: 0.375rem;
                font-size: 1.25rem;
            }
        }
        
        .header-top .mode-toggle-btn {
            position: relative;
            top: auto;
            right: auto;
            width: 44px;
            height: 44px;
            flex-shrink: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgb(var(--foreground));
            font-size: 1.5rem;
            transition: opacity 0.2s;
            border-radius: var(--radius);
            min-width: 44px;
        }
        
        .header-top .mode-toggle-btn:hover,
        .header-top .mode-toggle-btn:active {
            opacity: 0.7;
            background-color: rgba(var(--accent), 0.5);
        }
        
        .header-top .mode-toggle-btn:focus {
            outline: 2px solid rgb(var(--ring));
            outline-offset: 2px;
        }
        
        .header-top .mode-toggle-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #timerist-logo {
            display: block;
            width: 40px;
            height: 40px;
            color: #0a0a0a;
        }
        
        .header-top a {
            transition: opacity 0.2s ease;
        }
        
        .header-top a:hover {
            opacity: 0.7;
        }
        
        #timerist-logo circle,
        #timerist-logo line {
            stroke: #0a0a0a;
            stroke-width: 2.5;
        }
        
        [data-theme="style1"] #timerist-logo {
            color: #fafafa;
        }
        
        [data-theme="style1"] #timerist-logo circle,
        [data-theme="style1"] #timerist-logo line {
            stroke: #fafafa;
        }
        
        html[data-theme="style1"] #timerist-logo .logo-circle,
        html[data-theme="style1"] #timerist-logo .logo-line {
            stroke: #fafafa !important;
        }
    </style>
</head>
<body class="font-sans">
    <div class="container">
        <div class="header-top">
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <a href="index.html" style="display: flex; align-items: center; text-decoration: none; cursor: pointer;">
                    <svg
                        width="40"
                        height="40"
                        viewBox="0 0 40 40"
                        xmlns="http://www.w3.org/2000/svg"
                        id="timerist-logo"
                    >
                        <circle cx="20" cy="20" r="15" fill="none" stroke="#0a0a0a" stroke-width="2.5" class="logo-circle"/>
                        <line x1="20" y1="20" x2="20" y2="8" stroke="#0a0a0a" stroke-width="2.5" class="logo-line"/>
                        <line x1="20" y1="20" x2="30" y2="20" stroke="#0a0a0a" stroke-width="2.5" class="logo-line"/>
                    </svg>
                </a>
                <a href="index.html" style="font-size: clamp(1rem, 3vw, 1.5rem); font-weight: 600; color: rgb(var(--foreground)); text-decoration: none; cursor: pointer;">timerist.com</a>
                <span class="separator" style="color: rgb(var(--muted-foreground));">|</span>
                <span style="font-size: clamp(1rem, 3vw, 1.5rem); font-weight: 600; color: rgb(var(--foreground));">Mobility</span>
            </div>
            
            <div class="header-actions">
                <button class="mode-toggle-btn mode-toggle" id="themeToggleBtn" aria-label="Toggle dark mode">
                    <span id="theme-icon">ðŸŒ™</span>
                </button>
                <button class="hamburger-menu" id="menuBtn" aria-label="Open workout setup">
                    â˜°
                </button>
            </div>
        </div>
        
        <div class="timer-container" style="display: flex; flex-direction: column; gap: 1.5rem;">
            <!-- Timer Display -->
            <div class="timer-display-block bg-card border border-border rounded-lg shadow-lg text-center" id="timerDisplayBlock" role="button" tabindex="0" aria-label="Open workout setup">
                <!-- Workout Title -->
                <div id="workoutTitleDisplayBlock" style="display: none; text-align: center; padding-bottom: 1rem; margin-bottom: 1rem; border-bottom: 1px solid rgb(var(--border));">
                    <h2 id="workoutTitleText" style="font-size: 1.25rem; font-weight: 600; color: rgb(var(--foreground)); margin: 0; word-wrap: break-word;"></h2>
                </div>
                
                <div class="phase-label" id="phaseLabel"></div>
                <div class="timer-display-large" id="display">00:00</div>
                <div class="round-info">
                    <span id="roundInfo"></span>
                </div>
                
            </div>
            
            <!-- iOS: enable sound or dismiss (shown until audio unlocked or user chooses Silent) -->
            <div id="iosSoundBanner" class="p-3 rounded-xl bg-[rgb(var(--accent))] border border-[rgb(var(--border))] mb-3 text-center hidden" role="region" aria-label="Enable sound">
                <p class="text-sm font-medium text-[rgb(var(--foreground))] mb-2 m-0">On iPhone/iPad, tap below to enable sound before starting.</p>
                <div class="ios-sound-banner-buttons">
                    <button type="button" class="control-btn btn-primary" id="iosUnlockSoundBtn" aria-label="Enable sound">Enable Sound</button>
                    <button type="button" class="control-btn btn-secondary" id="iosSilentBtn" aria-label="Silent â€“ do not enable sound">Silent</button>
                </div>
            </div>
            
            <!-- Control Buttons -->
            <div class="control-buttons-card p-4 rounded-2xl bg-[rgb(var(--card))] border border-[rgb(var(--border))] shadow-lg">
                <div class="control-buttons-container" id="controlButtonsContainer">
                    <button class="control-btn btn-primary" id="startBtn" style="display: none;" aria-label="Start timer">Start</button>
                    <button class="control-btn btn-primary" id="pauseBtn" style="display: none;" aria-label="Pause timer">Pause</button>
                    <button class="control-btn btn-secondary" id="completeNextBtn" style="display: none;" aria-label="Complete round and move to next">Complete / Next</button>
                    <button class="control-btn btn-secondary" id="repeatWorkoutBtn" style="display: none;" aria-label="Repeat">Repeat</button>
                    <button class="control-btn btn-destructive" id="resetBtn" style="display: none;" aria-label="Reset timer">Reset</button>
                    <button class="control-btn btn-secondary" id="clearBtn" aria-label="Clear timer">Clear</button>
                    <button class="control-btn btn-primary" id="setupBtn" aria-label="Set up timer">Set Up</button>
                </div>
            </div>
            
            <!-- Workout Steps Display -->
            <div class="workout-steps-container" id="workoutStepsContainer" style="display: none;">
                <div class="workout-steps-list" id="workoutStepsList"></div>
            </div>
            
        </div>
    </div>
    
    <div class="sheet-overlay" id="drawerOverlay" aria-hidden="true"></div>
    
    <div class="bottom-sheet" id="settingsDrawer" role="dialog" aria-label="Workout setup">
        <div class="sheet-grabber" aria-hidden="true"></div>
        <div class="sheet-header">
            <h2 class="text-base font-semibold uppercase tracking-wide text-[rgb(var(--foreground))] m-0">Workout Setup</h2>
            <div class="sheet-header-actions">
                <button type="button" class="header-clear-btn" id="headerClearBtn" aria-label="Clear settings to defaults" title="Clear settings to defaults">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                </button>
                <button type="button" class="drawer-close" id="drawerCloseBtn" aria-label="Close">Ã—</button>
            </div>
        </div>
        <div class="sheet-content">
            <!-- Mobility Workout Presets -->
            <div class="sheet-section">
                <h3>Mobility Workouts</h3>
                <div class="input-group">
                    <label for="workoutSelect">Select Workout</label>
                    <select 
                        id="workoutSelect" 
                        class="workout-select"
                        aria-label="Select mobility workout"
                    >
                        <option value="custom" selected>Custom</option>
                        <option value="daily-wake-up">Daily Mobility Wake-Up (Wake & Shake)</option>
                        <option value="daily-foot-roll-relief">Daily Foot Roll Relief</option>
                        <option value="daily-ankle-stability-foam-pad">Daily Ankle Stability on Foam Pad</option>
                        <option value="worlds-greatest-stretch">World's Greatest Stretch</option>
                        <option value="90-90-hip-flow">90/90 Hip Flow</option>
                        <option value="thoracic-mobility-flow">Thoracic Mobility Flow</option>
                        <option value="shoulder-cars-dislocates">Shoulder CARs & Dislocates</option>
                        <option value="upper-body-desk-reset">Upper Body Desk Reset</option>
                    </select>
                    <p style="font-size: 0.75rem; color: rgb(var(--muted-foreground)); margin-top: 0.5rem;">
                        Select custom design your own workout using the "Create A Workout" section below.
                    </p>
                </div>
            </div>
            
            <!-- Workout Title -->
            <div class="sheet-section">
                <h3>Workout Title</h3>
                <div class="input-group">
                    <input type="text" id="workoutTitleInput" class="shadcn-input" placeholder="Enter workout name" maxlength="40" aria-label="Workout name">
                    <p style="font-size: 0.75rem; color: rgb(var(--muted-foreground)); margin-top: 0.25rem; display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: rgb(var(--destructive));">Maximum 40 characters.</span>
                        <span><span id="workoutTitleCharCount">0</span>/40</span>
                    </p>
                </div>
            </div>
            
            <!-- Workout Description -->
            <div class="sheet-section">
                <h3>Workout Description</h3>
                <div class="input-group">
                    <textarea 
                        id="workoutDescriptionInput" 
                        class="shadcn-textarea"
                        placeholder="Enter workout notes..."
                        aria-label="Workout notes"
                        rows="4"
                        maxlength="200"
                    ></textarea>
                    <p style="font-size: 0.75rem; color: rgb(var(--muted-foreground)); margin-top: 0.25rem; display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: rgb(var(--destructive));">Maximum 200 characters.</span>
                        <span><span id="workoutDescriptionCharCount">0</span>/200</span>
                    </p>
                </div>
            </div>
            
            <!-- Completion Message -->
            <div class="sheet-section">
                <h3>Completion Message</h3>
                <div class="input-group">
                    <input 
                        type="text" 
                        id="completionMessageInput" 
                        class="shadcn-input"
                        placeholder="Completed"
                        aria-label="Completion message"
                        maxlength="14"
                    >
                    <p style="font-size: 0.75rem; color: rgb(var(--muted-foreground)); margin-top: 0.25rem; display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: rgb(var(--destructive));">Maximum 14 characters.</span>
                        <span><span id="completionMessageCharCount">0</span>/14</span>
                    </p>
                </div>
            </div>
            
            <!-- Workout PREP Countdown (MM:SS) -->
            <div class="sheet-section">
                <h3>Workout PREP Countdown (MM:SS)</h3>
                <div class="time-slider-wrap">
                    <input type="range" id="prepTimeSlider" min="0" max="300" step="5" value="0" aria-label="Prep countdown seconds">
                </div>
                <div class="time-stepper-row">
                    <button type="button" class="stepper-btn" id="prepTimeDecreaseBtn" aria-label="Decrease prep time 10s">âˆ’10</button>
                    <input type="text" id="prepTimeInput" class="custom-time-input" value="00:00" placeholder="MM:SS" aria-label="Prep countdown">
                    <button type="button" class="stepper-btn" id="prepTimeIncreaseBtn" aria-label="Increase prep time 10s">+10</button>
                </div>
                <div class="input-group" style="margin-top: 0.75rem;">
                    <label for="prepPhaseLabelInput">Prep phase announcement (spoken and shown)</label>
                    <input type="text" id="prepPhaseLabelInput" class="shadcn-input" maxlength="20" value="Countdown" placeholder="e.g. Countdown, Prepare, Setup" aria-label="Prep phase label">
                </div>
            </div>
            
            <!-- Audio & Feedback -->
            <div class="sheet-section">
                <h3>Audio &amp; Feedback</h3>
                <label><input type="checkbox" id="enableTones" checked> Enable Audio Cues (tones)</label><br>
                <label><input type="checkbox" id="enableVoice" checked> Enable Audio Cues (voice)</label><br>
                <label><input type="checkbox" id="enableHaptic" checked> Enable Haptics (where supported)</label>
                <p class="text-xs text-[rgb(var(--muted-foreground))] mt-2">After you set workout duration above, choose when to hear an audible reminder.</p>
                <div id="reminderSection" style="display: none;" class="mt-3">
                    <p class="text-xs font-semibold uppercase tracking-wide text-[rgb(var(--muted-foreground))] mb-2">Audible reminders</p>
                    <div class="flex flex-col gap-2">
                        <label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" id="reminderMinutesRemain" aria-label="1/2 workout point"> 1/2 Workout Point <span id="reminderHalfwayText" class="text-[rgb(var(--muted-foreground))]">â€” alerts at â€” min remaining</span></label>
                        <label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" id="reminder2Min" aria-label="2 minutes remain"> 2 Minutes Remain</label>
                        <label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" id="reminder1Min" aria-label="1 minute remains"> 1 Minute Remains</label>
                    </div>
                </div>
            </div>
            
            <!-- Export/Import -->
            <div class="sheet-section">
                <h3>Export / Import</h3>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="control-btn btn-primary" id="exportBtn" style="flex: 1;">Export JSON</button>
                    <button class="control-btn btn-secondary" id="importBtn" style="flex: 1;">Import JSON</button>
                </div>
                <input type="file" id="importFileInput" accept=".json" style="display: none;">
            </div>
            
            <!-- Round Groups -->
            <div class="sheet-section">
                <h3>Create Your Own Workout</h3>
                <div id="roundGroupsContainer"></div>
                <button class="btn-add" id="addRoundGroupBtn" style="width: 100%;">+ Add Round Group</button>
            </div>
            
            <div class="sheet-section">
                <button type="button" id="clearAllSettingsBtn" class="btn-clear-all-settings" aria-label="Clear all settings">Clear All Settings</button>
            </div>
            
            <!-- About This Timer -->
            <div class="sheet-section">
                <h3>About This Timer</h3>
                <p>
                    Create custom workouts with multiple activities, round groups, and various modes (time-based, rep-based). 
                    Perfect for complex training sessions with multiple exercises, rest periods, and rounds.
                </p>
                <p style="margin-top: 0.75rem;">
                    <strong>Keywords:</strong> custom workout timer, multi-activity timer, workout builder, fitness timer, interval timer, rep counter.
                </p>
            </div>
            
            <!-- General Info -->
            <div class="sheet-section">
                <h3>General Info</h3>
                <p><strong>Version:</strong> v0.13</p>
                <p><strong>Released:</strong> <span id="releaseDate">2024-01-15</span></p>
            </div>
        </div>
    </div>
    
    <div class="hidden"><input type="checkbox" id="haptic-switch" switch><label for="haptic-switch" id="haptic-label"></label></div>
    
    <script>
        // Global state
        let roundGroups = [];
        let currentWorkoutState = null;
        let timerInterval = null;
        let isRunning = false;
        let isPaused = false;
        let isArmed = false; // Ready state - waiting for user to start next round
        let isWorkoutComplete = false; // Track if workout has been completed
        let currentPhase = 'ready';
        let currentRoundGroupIndex = 0;
        let currentActivityIndex = 0;
        let currentRound = 1;
        let currentTime = 0;
        let workoutStartTime = null;
        let startTimestamps = []; // Array to track when Start button was pressed
        let timeOfDayInterval = null; // Interval to update time of day display for rep-based rounds
        let repBasedSegmentTimes = []; // Array to track start/stop times for rep-based segments
        let lastBeepTime = {}; // Track last beep time per countdown type to prevent double-firing
        // EMOM tracking
        let emomCurrentMinute = 1; // Current minute in EMOM (1-based)
        let emomTotalMinutes = 0; // Total minutes for EMOM phase
        let emomSecondsInMinute = 60; // Seconds remaining in current minute
        
        // DOM elements
        const display = document.getElementById('display');
        const phaseLabel = document.getElementById('phaseLabel');
        // Status text removed - no longer displayed
        const workoutTitleDisplay = document.getElementById('workoutTitleDisplay');
        const roundInfo = document.getElementById('roundInfo');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const completeNextBtn = document.getElementById('completeNextBtn');
        const repeatWorkoutBtn = document.getElementById('repeatWorkoutBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearBtn = document.getElementById('clearBtn');
        const setupBtn = document.getElementById('setupBtn');
        const workoutStepsContainer = document.getElementById('workoutStepsContainer');
        const workoutStepsList = document.getElementById('workoutStepsList');
        const roundGroupsContainer = document.getElementById('roundGroupsContainer');
        const addRoundGroupBtn = document.getElementById('addRoundGroupBtn');
        const workoutTitleInput = document.getElementById('workoutTitleInput');
        const workoutTitleText = document.getElementById('workoutTitleText');
        const workoutTitleDisplayBlock = document.getElementById('workoutTitleDisplayBlock');
        const workoutTitleCharCount = document.getElementById('workoutTitleCharCount');
        const workoutDescriptionInput = document.getElementById('workoutDescriptionInput');
        const workoutDescriptionDisplay = document.getElementById('workoutDescriptionDisplay');
        const workoutDescriptionText = document.getElementById('workoutDescriptionText');
        const workoutDescriptionCharCount = document.getElementById('workoutDescriptionCharCount');
        const completionMessageInput = document.getElementById('completionMessageInput');
        const completionMessageCharCount = document.getElementById('completionMessageCharCount');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFileInput = document.getElementById('importFileInput');
        const workoutSelect = document.getElementById('workoutSelect');
        const enableTonesEl = document.getElementById('enableTones');
        const enableVoiceEl = document.getElementById('enableVoice');
        const enableHapticEl = document.getElementById('enableHaptic');
        const reminderMinutesRemainEl = document.getElementById('reminderMinutesRemain');
        const reminder2MinEl = document.getElementById('reminder2Min');
        const reminder1MinEl = document.getElementById('reminder1Min');
        const prepTimeInput = document.getElementById('prepTimeInput');
        const prepTimeSlider = document.getElementById('prepTimeSlider');
        const prepTimeDecreaseBtn = document.getElementById('prepTimeDecreaseBtn');
        const prepTimeIncreaseBtn = document.getElementById('prepTimeIncreaseBtn');
        const prepPhaseLabelInput = document.getElementById('prepPhaseLabelInput');
        
        // Audio & feedback: load from localStorage
        if (enableTonesEl) { try { enableTonesEl.checked = localStorage.getItem('enableTones') !== 'false'; } catch (e) {} }
        if (enableVoiceEl) { try { enableVoiceEl.checked = localStorage.getItem('enableVoice') !== 'false'; } catch (e) {} }
        if (enableHapticEl) { try { enableHapticEl.checked = localStorage.getItem('enableHaptic') !== 'false'; } catch (e) {} }
        if (enableTonesEl) enableTonesEl.addEventListener('change', function() { try { localStorage.setItem('enableTones', enableTonesEl.checked); } catch (e) {} });
        if (enableVoiceEl) enableVoiceEl.addEventListener('change', function() { try { localStorage.setItem('enableVoice', enableVoiceEl.checked); } catch (e) {} });
        if (enableHapticEl) enableHapticEl.addEventListener('change', function() { try { localStorage.setItem('enableHaptic', enableHapticEl.checked); } catch (e) {} });
        if (reminderMinutesRemainEl) { try { reminderMinutesRemainEl.checked = localStorage.getItem('reminderMinutesRemain') === 'true'; } catch (e) {} }
        if (reminder2MinEl) { try { reminder2MinEl.checked = localStorage.getItem('reminder2Min') === 'true'; } catch (e) {} }
        if (reminder1MinEl) { try { reminder1MinEl.checked = localStorage.getItem('reminder1Min') === 'true'; } catch (e) {} }
        if (reminderMinutesRemainEl) reminderMinutesRemainEl.addEventListener('change', function() { try { localStorage.setItem('reminderMinutesRemain', reminderMinutesRemainEl.checked); } catch (e) {} });
        if (reminder2MinEl) reminder2MinEl.addEventListener('change', function() { try { localStorage.setItem('reminder2Min', reminder2MinEl.checked); } catch (e) {} });
        if (reminder1MinEl) reminder1MinEl.addEventListener('change', function() { try { localStorage.setItem('reminder1Min', reminder1MinEl.checked); } catch (e) {} });
        // Prep phase: load from localStorage
        if (prepTimeInput) {
            try {
                const prepSec = parseInt(localStorage.getItem('mobility-prepTimeSeconds') || '0', 10);
                prepTimeInput.value = prepSec >= 60 ? formatTime(prepSec) : (prepSec > 0 ? String(prepSec) : '00:00');
                if (prepTimeSlider) prepTimeSlider.value = Math.min(300, Math.max(0, prepSec));
            } catch (e) {}
        }
        if (prepPhaseLabelInput) { try { prepPhaseLabelInput.value = localStorage.getItem('mobility-prepPhaseLabel') || 'Countdown'; } catch (e) {} }
        
        // Mobility workout presets
        const mobilityWorkouts = {
            'daily-wake-up': {
                title: 'Daily Mobility Wake-Up (Wake & Shake)',
                description: 'A preset 7-minute morning shake-out to loosen joints, boost energy, improve circulation, and prime your body for the day. 7 gentle movements Ã— 60 seconds each.',
                roundGroups: [
                    {
                        id: 'mku5m9cpc80pbnqzbq6',
                        name: '7 Minute Mobility Flow',
                        rounds: 1,
                        restBetweenRounds: 0,
                        activities: [
                            {
                                name: 'Light Hops with Arm Shake',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'hop lightly in place while shaking arms loose to wake up the upper body',
                                audioEnabled: true
                            },
                            {
                                name: 'Squat to Overhead Arm Reach',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'gentle squat with arms swinging from sides up overhead for full-body reach',
                                audioEnabled: true
                            },
                            {
                                name: 'Alternating Arm Raises',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'stand tall, raise one arm overhead at a time, alternating sides',
                                audioEnabled: true
                            },
                            {
                                name: 'Standing Trunk Twists',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'rotate torso side to side with controlled momentum, arms following',
                                audioEnabled: true
                            },
                            {
                                name: 'Dead Arm Swings',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'let arms hang completely relaxed, swing them naturally across the body',
                                audioEnabled: true
                            },
                            {
                                name: 'Standing Rotational Swings (Golf Swings)',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'torso and arms swing side to side like a golf swing, hips rotating',
                                audioEnabled: true
                            },
                            {
                                name: 'High Knees to Hands',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'march in place, lifting alternating knees to meet raised hands at waist height',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'daily-foot-roll-relief': {
                title: 'Daily Foot Roll Relief',
                description: 'A 12-minute routine to relieve plantar fasciitis: roll each foot over 6 progressively sized spheres (60s each) to loosen fascia, ease heel/arch pain, boost circulation and reduce stiffness.',
                roundGroups: [
                    {
                        id: 'mkuaxf9tl9kh5ccv5j',
                        name: 'Sphere Foot Therapy',
                        rounds: 6,
                        restBetweenRounds: 0,
                        activities: [
                            {
                                name: 'Right Foot ',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Roll foot heel-to-toes over sphere with moderate pressure. Pause on tight spots, small circles. Increase weight as tolerated.',
                                audioEnabled: true
                            },
                            {
                                name: 'Left Foot',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Roll foot heel-to-toes over sphere with moderate pressure. Pause on tight spots, small circles. Increase weight as tolerated.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'daily-ankle-stability-foam-pad': {
                title: 'Daily Ankle Stability on Foam Pad',
                description: 'Physical-therapy protocol to strengthen ankles, Achilles, and improve proprioception/balance. Uses an oval foam balance pad. 5 rounds of slight-knee-bend single-leg balance (30s each leg), followed by 1-minute static holds on each leg.',
                roundGroups: [
                    {
                        id: 'anklepad1',
                        name: 'Knee-Bend Balance (30s per leg)',
                        rounds: 5,
                        restBetweenRounds: 10,
                        activities: [
                            {
                                name: 'Right Leg - Slight Knee Bend',
                                mode: 'time',
                                duration: 30,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Stand on oval foam pad, one leg, knee bent ~30-45Â°, hold balance. Keep core engaged, slight knee flexion. Do not go too deep.',
                                audioEnabled: true
                            },
                            {
                                name: 'Left Leg - Slight Knee Bend',
                                mode: 'time',
                                duration: 30,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Stand on oval foam pad, one leg, knee bent ~30-45Â°, hold balance. Keep core engaged, slight knee flexion. Do not go too deep.',
                                audioEnabled: true
                            }
                        ]
                    },
                    {
                        id: 'anklepad2',
                        name: 'Static Single-Leg Balance',
                        rounds: 1,
                        restBetweenRounds: 0,
                        activities: [
                            {
                                name: 'Right Leg - Static Hold',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Stand on oval foam pad, one leg, knee straight or very slight bend, hold steady balance for full minute.',
                                audioEnabled: true
                            },
                            {
                                name: 'Left Leg - Static Hold',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Stand on oval foam pad, one leg, knee straight or very slight bend, hold steady balance for full minute.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'worlds-greatest-stretch': {
                title: "World's Greatest Stretch",
                description: "Dynamic full-body flow: hips, hamstrings, thoracic rotation, shoulders. Great pre-workout or daily reset. 1-2 rounds, alternate sides.",
                roundGroups: [
                    {
                        id: 'wgs1',
                        name: 'Sequence Flow (per side)',
                        rounds: 2,
                        restBetweenRounds: 15,
                        activities: [
                            {
                                name: 'Lunge + Hip Flexor Hold',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Deep lunge, back knee down or up, squeeze glute, hands inside front foot. Breathe deeply.',
                                audioEnabled: true
                            },
                            {
                                name: 'Thoracic Reach + Rotation',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'From lunge, reach opposite arm overhead, rotate torso open. Keep hips square.',
                                audioEnabled: true
                            },
                            {
                                name: 'Hamstring Straighten',
                                mode: 'time',
                                duration: 30,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Straighten front leg, hinge forward gently for hamstring stretch. Switch sides after full sequence.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            '90-90-hip-flow': {
                title: '90/90 Hip Flow',
                description: 'Deep hip opener for internal/external rotation. Ideal for squat depth, runners, desk sitters. ~10 min total.',
                roundGroups: [
                    {
                        id: '90901',
                        name: '90/90 Positions (per side)',
                        rounds: 1,
                        restBetweenRounds: 0,
                        activities: [
                            {
                                name: '90/90 Forward Lean',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 30,
                                notes: 'Front leg 90Â°, back leg 90Â°. Lean forward over front shin. Breathe into stretch.',
                                audioEnabled: true
                            },
                            {
                                name: '90/90 Back Leg Lift',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 30,
                                notes: 'Lift back foot/heel off ground, hold. Keep hips square. Switch sides after set.',
                                audioEnabled: true
                            },
                            {
                                name: '90/90 Passive Hold',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Sit tall in 90/90, relax into position. Deep breaths. Repeat flow on opposite side.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'thoracic-mobility-flow': {
                title: 'Thoracic Mobility Flow',
                description: 'Improve mid-back rotation & extension. Great for posture, desk workers, shoulder health. ~8-10 min.',
                roundGroups: [
                    {
                        id: 'thor1',
                        name: 'Thoracic Sequence',
                        rounds: 2,
                        restBetweenRounds: 20,
                        activities: [
                            {
                                name: 'Cat-Cow Flow',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'On all fours, alternate arching (cow) and rounding (cat) spine. Move with breath.',
                                audioEnabled: true
                            },
                            {
                                name: 'Thread the Needle',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 15,
                                notes: 'Thread arm under opposite arm, rest shoulder on ground. Rotate mid-back. Switch sides.',
                                audioEnabled: true
                            },
                            {
                                name: 'Quadruped Rotation',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Hand behind head, rotate elbow up toward ceiling. Keep hips stable. Switch sides.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'shoulder-cars-dislocates': {
                title: 'Shoulder CARs & Dislocates',
                description: 'Controlled rotations + overhead mobility for shoulder health & range. Warm-up or daily. ~10 min.',
                roundGroups: [
                    {
                        id: 'shoulder1',
                        name: 'Shoulder Mobility',
                        rounds: 2,
                        restBetweenRounds: 15,
                        activities: [
                            {
                                name: 'Shoulder CARs (each arm)',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Large controlled circles: forward â†’ up â†’ back â†’ down. Slow & full range. Switch arms.',
                                audioEnabled: true
                            },
                            {
                                name: 'Shoulder Dislocates',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 30,
                                notes: 'Use band/stick/broom. Pass overhead to behind back & return. Keep arms straight.',
                                audioEnabled: true
                            },
                            {
                                name: 'Wall Angels',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: "Back to wall, slide arms up/down in 'W' to 'Y'. Keep elbows/shoulders in contact.",
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            },
            'upper-body-desk-reset': {
                title: 'Upper Body Desk Reset',
                description: 'Preset neck, shoulder, wrist, thoracic release for desk workers. Reduces tension fast. ~8 min.',
                roundGroups: [
                    {
                        id: 'desk1',
                        name: 'Desk Flow',
                        rounds: 1,
                        restBetweenRounds: 0,
                        activities: [
                            {
                                name: 'Neck Tilts + Chin Tucks',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Side tilts 20s each, then chin tucks x10 slow. Gentle, no forcing.',
                                audioEnabled: true
                            },
                            {
                                name: 'Wrist Flexor/Extensor Stretch',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 15,
                                notes: 'Palms up then down, gentle pull back. 20-25s each direction. Switch arms.',
                                audioEnabled: true
                            },
                            {
                                name: 'Shoulder Rolls + Arm Circles',
                                mode: 'time',
                                duration: 60,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Big rolls forward/back, then arm circles both directions. Slow & controlled.',
                                audioEnabled: true
                            },
                            {
                                name: 'Prayer + Reverse Prayer',
                                mode: 'time',
                                duration: 45,
                                repsTarget: 0,
                                restBetweenActivities: 0,
                                notes: 'Hands together front, then behind back if possible. Gentle lift. Breathe.',
                                audioEnabled: true
                            }
                        ]
                    }
                ]
            }
        };
        
        // Load mobility workout
        function loadMobilityWorkout(workoutKey) {
            if (workoutKey === 'custom') {
                // Clear workout and reset to custom
                roundGroups = [];
                workoutTitleInput.value = '';
                if (workoutDescriptionInput) {
                    workoutDescriptionInput.value = '';
                }
                if (completionMessageInput) {
                    completionMessageInput.value = 'Completed';
                }
                updateCharCounts();
                updateWorkoutDisplay();
                renderActivities();
                updateWorkoutSteps();
                updateButtonStates();
                updateDisplay();
                return;
            }
            
            const workout = mobilityWorkouts[workoutKey];
            if (!workout) {
                alert('Workout not found.');
                return;
            }
            
            // Stop timer if running or paused
            if (isRunning || isPaused) {
                stopTimer();
                resetTimer(); // Ensure all state is reset
            }
            
            // Load workout data
            roundGroups = JSON.parse(JSON.stringify(workout.roundGroups)); // Deep copy
            workoutTitleInput.value = workout.title;
            if (workoutDescriptionInput) {
                workoutDescriptionInput.value = workout.description || '';
            }
            if (completionMessageInput) {
                completionMessageInput.value = workout.completionMessage || 'Completed';
            }
            
            // Default missing audioEnabled to true for backward compatibility
            roundGroups.forEach(rg => {
                if (rg.activities) {
                    rg.activities.forEach(act => {
                        if (act.audioEnabled === undefined) {
                            act.audioEnabled = true;
                        }
                    });
                }
            });
            
            updateCharCounts();
            updateWorkoutDisplay();
            renderActivities();
            updateWorkoutSteps();
            updateButtonStates();
            updateDisplay();
        }
        
        // Utility functions
        function parseTime(timeString) {
            if (!timeString) return 0;
            const parts = timeString.split(':');
            if (parts.length === 2) {
                const minutes = parseInt(parts[0]) || 0;
                const seconds = parseInt(parts[1]) || 0;
                return (minutes * 60) + seconds;
            }
            return parseInt(timeString) || 0;
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        
        // Format time of day in 12-hour format with AM/PM (like clock.html)
        function formatTimeOfDay() {
            const now = new Date();
            let hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            
            // Convert to 12-hour format
            if (hours === 0) {
                hours = 12; // Midnight
            } else if (hours > 12) {
                hours = hours - 12; // Afternoon hours
            }
            // hours === 12 stays as 12 (noon)
            
            // Pad with zeros
            const hoursStr = String(hours).padStart(2, '0');
            const minutesStr = String(minutes).padStart(2, '0');
            const secondsStr = String(seconds).padStart(2, '0');
            
            return `${hoursStr}:${minutesStr}:${secondsStr} ${ampm}`;
        }
        
        function formatTimestamp(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        function recordStartTimestamp() {
            if (!currentWorkoutState) return;
            
            // Find the work phase for the current activity
            // When Start is pressed, find the work phase
            let workPhase = null;
            const currentPhaseIndex = currentWorkoutState.currentPhaseIndex;
            
            // Look for the work phase in the current activity
            for (let i = currentPhaseIndex; i < currentWorkoutState.phases.length; i++) {
                const phase = currentWorkoutState.phases[i];
                if (phase.type === 'work') {
                    workPhase = phase;
                    break;
                }
                // If we've moved to a different activity, stop looking
                if (i > currentPhaseIndex) {
                    const prevPhase = currentWorkoutState.phases[i - 1];
                    if (prevPhase.roundGroupIndex !== phase.roundGroupIndex ||
                        prevPhase.activityIndex !== phase.activityIndex ||
                        prevPhase.round !== phase.round) {
                        break;
                    }
                }
            }
            
            if (!workPhase) {
                // Fallback to current phase if no work phase found
                workPhase = currentWorkoutState.phases[currentPhaseIndex];
            }
            
            const timestamp = new Date();
            const rg = roundGroups[workPhase.roundGroupIndex];
            const act = workPhase.activity;
            
            const entry = {
                timestamp: timestamp,
                roundGroupIndex: workPhase.roundGroupIndex,
                activityIndex: workPhase.activityIndex,
                round: workPhase.round,
                roundGroupName: rg ? (rg.name || `Group ${workPhase.roundGroupIndex + 1}`) : '',
                activityName: act.name,
                phaseType: workPhase.type
            };
            
            startTimestamps.push(entry);
            updateWorkoutSteps(); // Refresh workout steps to show timestamp
        }
        
        function getTimestampForStep(rgIndex, actIndex, round) {
            return startTimestamps.find(entry => 
                entry.roundGroupIndex === rgIndex &&
                entry.activityIndex === actIndex &&
                entry.round === round
            );
        }
        
        function getRepBasedSegmentForStep(rgIndex, actIndex, round) {
            return repBasedSegmentTimes.find(entry => 
                entry.roundGroupIndex === rgIndex &&
                entry.activityIndex === actIndex &&
                entry.round === round
            );
        }
        
        // Track start/stop times for rep-based segments
        function recordRepBasedSegmentStart() {
            if (!currentWorkoutState) return;
            
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!phase || phase.type !== 'work' || !phase.activity || phase.activity.mode !== 'rep') {
                return; // Not a rep-based work phase
            }
            
            // Check if we already have a start time for this segment (don't overwrite if already started)
            const existingEntry = repBasedSegmentTimes.find(e => 
                e.roundGroupIndex === phase.roundGroupIndex &&
                e.activityIndex === phase.activityIndex &&
                e.round === phase.round &&
                e.startTime !== null
            );
            
            if (existingEntry && existingEntry.stopTime === null) {
                // Already started and not stopped, don't overwrite
                return;
            }
            
            const startTime = new Date();
            const act = phase.activity;
            
            const entry = {
                roundGroupIndex: phase.roundGroupIndex,
                activityIndex: phase.activityIndex,
                round: phase.round,
                activityName: act.name,
                startTime: startTime,
                stopTime: null
            };
            
            // Check if entry already exists (for same round/activity)
            const existingIndex = repBasedSegmentTimes.findIndex(e => 
                e.roundGroupIndex === phase.roundGroupIndex &&
                e.activityIndex === phase.activityIndex &&
                e.round === phase.round
            );
            
            if (existingIndex >= 0) {
                // Update existing entry
                repBasedSegmentTimes[existingIndex].startTime = startTime;
                repBasedSegmentTimes[existingIndex].stopTime = null;
            } else {
                // Add new entry
                repBasedSegmentTimes.push(entry);
            }
            
            updateSegmentTimesDisplay();
            updateWorkoutSteps(); // Refresh workout steps to show start time
        }
        
        // Check if we just entered a rep-based work phase and record start time
        function checkAndRecordRepBasedStart() {
            if (!currentWorkoutState || !isRunning) return;
            
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (phase && phase.type === 'work' && phase.activity && phase.activity.mode === 'rep') {
                recordRepBasedSegmentStart();
            }
        }
        
        function recordRepBasedSegmentStop() {
            if (!currentWorkoutState) return;
            
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!phase || phase.type !== 'work' || !phase.activity || phase.activity.mode !== 'rep') {
                return; // Not a rep-based work phase
            }
            
            const stopTime = new Date();
            
            // Find the current entry
            const entryIndex = repBasedSegmentTimes.findIndex(e => 
                e.roundGroupIndex === phase.roundGroupIndex &&
                e.activityIndex === phase.activityIndex &&
                e.round === phase.round &&
                e.stopTime === null
            );
            
            if (entryIndex >= 0) {
                repBasedSegmentTimes[entryIndex].stopTime = stopTime;
                updateSegmentTimesDisplay();
                updateWorkoutSteps(); // Refresh workout steps to show stop time
            }
        }
        
        function getCurrentRepBasedSegment() {
            if (!currentWorkoutState) return null;
            
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!phase || phase.type !== 'work' || !phase.activity || phase.activity.mode !== 'rep') {
                return null;
            }
            
            return repBasedSegmentTimes.find(e => 
                e.roundGroupIndex === phase.roundGroupIndex &&
                e.activityIndex === phase.activityIndex &&
                e.round === phase.round
            );
        }
        
        function updateSegmentTimesDisplay() {
            // Segment times are now only displayed in the workout steps list, not in the main timer display
            // This function is kept for compatibility but does nothing
        }
        
        // Format time of day for a specific date (for start/stop times)
        function formatTimeOfDayForDate(date) {
            let hours = date.getHours();
            const minutes = date.getMinutes();
            const seconds = date.getSeconds();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            
            // Convert to 12-hour format
            if (hours === 0) {
                hours = 12; // Midnight
            } else if (hours > 12) {
                hours = hours - 12; // Afternoon hours
            }
            
            // Pad with zeros
            const hoursStr = String(hours).padStart(2, '0');
            const minutesStr = String(minutes).padStart(2, '0');
            const secondsStr = String(seconds).padStart(2, '0');
            
            return `${hoursStr}:${minutesStr}:${secondsStr} ${ampm}`;
        }
        
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        // Sheet/Drawer functions (must be global)
        function openSheet() {
            const drawer = document.getElementById('settingsDrawer');
            const overlay = document.getElementById('drawerOverlay');
            if (drawer && overlay) {
                drawer.classList.add('open');
                overlay.classList.add('open');
            }
        }
        window.openSheet = openSheet;
        window.toggleDrawer = function() {
            const drawer = document.getElementById('settingsDrawer');
            const overlay = document.getElementById('drawerOverlay');
            if (drawer && overlay) {
                drawer.classList.toggle('open');
                overlay.classList.toggle('open');
            }
        };
        window.closeDrawer = function() {
            const drawer = document.getElementById('settingsDrawer');
            const overlay = document.getElementById('drawerOverlay');
            if (drawer && overlay) {
                drawer.classList.remove('open');
                overlay.classList.remove('open');
            }
        };
        
        // Validation
        function hasValidTimerData() {
            if (roundGroups.length === 0) return false;
            
            for (let rg of roundGroups) {
                if (!rg.rounds || rg.rounds < 1) return false;
                if (rg.activities.length === 0) return false;
                for (let act of rg.activities) {
                    if (!act.name || act.name.trim() === '') return false;
                    if (act.mode === 'time' && (!act.duration || act.duration <= 0)) return false;
                    if (act.mode === 'rep' && (!act.repsTarget || act.repsTarget <= 0) && (!act.duration || act.duration <= 0)) return false;
                }
            }
            return true;
        }
        
        let reminderFiredHalf = false;
        let reminderFired2Min = false;
        let reminderFired1Min = false;
        
        function getTotalDuration() {
            if (currentWorkoutState && currentWorkoutState.phases.length > 0) {
                return currentWorkoutState.phases.filter(p => p.type !== 'prep').reduce((sum, p) => sum + (p.duration || 0), 0);
            }
            const state = buildWorkoutState();
            return state.phases.filter(p => p.type !== 'prep').reduce((sum, p) => sum + (p.duration || 0), 0);
        }
        function getTotalRemaining() {
            if (!currentWorkoutState || !currentWorkoutState.phases.length) return 0;
            let elapsed = 0;
            for (let i = 0; i < currentWorkoutState.currentPhaseIndex; i++) {
                const p = currentWorkoutState.phases[i];
                if (p.type !== 'prep') elapsed += p.duration || 0;
            }
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (phase && phase.type !== 'prep') {
                elapsed += (phase.duration || 0) - currentTime;
            }
            return Math.max(0, getTotalDuration() - elapsed);
        }
        function updateReminderDisplays() {
            const total = getTotalDuration();
            const reminderSection = document.getElementById('reminderSection');
            if (reminderSection) reminderSection.style.display = total > 0 ? 'block' : 'none';
            const halfwayEl = document.getElementById('reminderHalfwayText');
            if (halfwayEl && total > 0) {
                const halfSec = Math.round(total / 2);
                const halfMin = Math.round(halfSec / 60);
                halfwayEl.textContent = halfMin === 1 ? 'â€” alerts at 1 min remaining' : 'â€” alerts at ' + halfMin + ' min remaining';
            } else if (halfwayEl) halfwayEl.textContent = 'â€” alerts at â€” min remaining';
        }
        
        function readPrepTimeFromInput() {
            if (!prepTimeInput) return 0;
            const sec = parseTime(prepTimeInput.value);
            return Math.min(300, Math.max(0, sec));
        }
        function getPrepPhaseLabel() {
            return (prepPhaseLabelInput && prepPhaseLabelInput.value.trim()) ? prepPhaseLabelInput.value.trim() : 'Countdown';
        }
        
        // Build workout state
        function buildWorkoutState() {
            const state = {
                phases: [],
                currentPhaseIndex: 0
            };
            const prepSec = readPrepTimeFromInput();
            if (prepSec > 0) {
                state.phases.push({
                    type: 'prep',
                    roundGroupIndex: -1,
                    activityIndex: -1,
                    round: 0,
                    duration: prepSec,
                    activity: null,
                    prepLabel: getPrepPhaseLabel()
                });
            }
            for (let rgIndex = 0; rgIndex < roundGroups.length; rgIndex++) {
                const rg = roundGroups[rgIndex];
                for (let round = 1; round <= rg.rounds; round++) {
                    for (let actIndex = 0; actIndex < rg.activities.length; actIndex++) {
                        const act = rg.activities[actIndex];
                        
                        // Work phase
                        state.phases.push({
                            type: 'work',
                            roundGroupIndex: rgIndex,
                            activityIndex: actIndex,
                            round: round,
                            duration: act.duration || 0,
                            activity: act
                        });
                        
                        // Rest between activities (after each activity, except after the last activity of the last round)
                        // Add rest if: not the last activity of the last round
                        const isLastActivityOfLastRound = (round === rg.rounds && actIndex === rg.activities.length - 1);
                        if (!isLastActivityOfLastRound && act.restBetweenActivities > 0) {
                            state.phases.push({
                                type: 'rest',
                                roundGroupIndex: rgIndex,
                                activityIndex: actIndex,
                                round: round,
                                duration: act.restBetweenActivities,
                                activity: act
                            });
                        }
                        
                        // Rest between rounds (after completing all activities in a round, before starting next round)
                        // Add rest if: this is the last activity of this round, and there are more rounds
                        if (round < rg.rounds && actIndex === rg.activities.length - 1) {
                            if (rg.restBetweenRounds > 0) {
                                state.phases.push({
                                    type: 'rest',
                                    roundGroupIndex: rgIndex,
                                    activityIndex: actIndex,
                                    round: round,
                                    duration: rg.restBetweenRounds,
                                    activity: act
                                });
                            }
                        }
                        
                    }
                }
            }
            
            return state;
        }
        
        // Helper function to calculate current activity number and total activities
        function getActivityCounts(phase) {
            if (!phase || !roundGroups || roundGroups.length === 0) {
                return { currentActivity: 1, totalActivities: 1 };
            }
            
            // Calculate total activities across all round groups
            let totalActivities = 0;
            for (let rg of roundGroups) {
                totalActivities += rg.activities ? rg.activities.length : 0;
            }
            
            // Calculate current activity number
            let currentActivity = 0; // Start at 0, will add 1 at end
            // Sum all activities in previous round groups
            for (let rgIndex = 0; rgIndex < phase.roundGroupIndex; rgIndex++) {
                if (roundGroups[rgIndex] && roundGroups[rgIndex].activities) {
                    currentActivity += roundGroups[rgIndex].activities.length;
                }
            }
            // Add the current activity index (0-based) and convert to 1-based
            currentActivity += phase.activityIndex + 1;
            
            return { currentActivity, totalActivities };
        }
        
        // Start/stop time of day update interval for rep-based work phases
        function updateTimeOfDayInterval() {
            // Clear any existing interval
            if (timeOfDayInterval) {
                clearInterval(timeOfDayInterval);
                timeOfDayInterval = null;
            }
            
            // Start interval if we're in a rep-based work phase with no duration
            if (currentWorkoutState && isRunning && !isPaused) {
                const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                if (!phase) return;
                
                const act = phase.activity;
                if (!act) return;
                
                const hasNoDuration = (act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                      (phase.duration === 0 || phase.duration === null || phase.duration === undefined);
                const isRepBasedWorkWithNoDuration = phase.type === 'work' && 
                    act.mode === 'rep' && hasNoDuration;
                
                if (isRepBasedWorkWithNoDuration) {
                    // Record start time for this rep-based segment
                    recordRepBasedSegmentStart();
                    // Update immediately to show time of day
                    updateDisplay();
                    updateButtonStates(); // Ensure Complete/Next button is visible
                    // Then update every second
                    timeOfDayInterval = setInterval(() => {
                        updateDisplay();
                    }, 1000);
                }
            }
        }
        
        // Check if transitioning to a different activity (activity boundary)
        function isActivityBoundary(currentPhaseIndex, nextPhaseIndex) {
            if (!currentWorkoutState || nextPhaseIndex >= currentWorkoutState.phases.length) {
                return false;
            }
            
            const currentPhase = currentWorkoutState.phases[currentPhaseIndex];
            const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
            
            if (!currentPhase || !nextPhase) {
                return false;
            }
            
            // Check if we're moving to a different activity or round
            return (
                currentPhase.roundGroupIndex !== nextPhase.roundGroupIndex ||
                currentPhase.activityIndex !== nextPhase.activityIndex ||
                currentPhase.round !== nextPhase.round
            );
        }
        
        // Update display
        function updateDisplay() {
            if (!currentWorkoutState || currentWorkoutState.phases.length === 0) {
                display.textContent = '00:00';
                phaseLabel.textContent = '';
                roundInfo.textContent = '';
                return;
            }
            
            // Handle armed state (ready for next round)
            if (isArmed && !isRunning && !isPaused) {
                const nextPhaseIndex = currentWorkoutState.currentPhaseIndex;
                if (nextPhaseIndex < currentWorkoutState.phases.length) {
                    const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                    const nextAct = nextPhase.activity;
                    const rg = roundGroups[nextPhase.roundGroupIndex];
                    display.textContent = '00:00';
                    phaseLabel.textContent = `Ready for next round: ${nextAct.name}`;
                    if (rg) {
                        const activityCounts = getActivityCounts(nextPhase);
                        roundInfo.textContent = `${rg.name || 'Group'} ${nextPhase.round} of ${rg.rounds} Activity ${activityCounts.currentActivity} of ${activityCounts.totalActivities} - ${nextAct.name}`;
                    }
                    return;
                }
            }
            
            // Check if workout is complete
            if (isWorkoutComplete) {
                display.textContent = '00:00';
                const completionMessage = completionMessageInput && completionMessageInput.value.trim() 
                    ? completionMessageInput.value.trim() 
                    : 'Completed';
                phaseLabel.textContent = completionMessage;
                roundInfo.textContent = '';
                return;
            }
            
            const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!phase) {
                display.textContent = '00:00';
                phaseLabel.textContent = 'Completed';
                roundInfo.textContent = '';
                return;
            }
            
            const act = phase.activity;
            let displayText = '';
            let phaseText = '';
            
            if (phase.type === 'prep') {
                phaseText = phase.prepLabel || getPrepPhaseLabel();
                displayText = formatTime(currentTime);
                roundInfo.textContent = '';
                display.classList.remove('warning', 'danger');
                if (currentTime <= 3 && currentTime > 0) display.classList.add('warning');
                if (currentTime <= 1 && currentTime > 0) display.classList.add('danger');
            } else if (phase.type === 'work') {
                // Check if rep-based with no duration
                const hasNoDuration = (act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                      (phase.duration === 0 || phase.duration === null || phase.duration === undefined);
                
                if (act.mode === 'rep' && hasNoDuration) {
                    // Rep-based with no duration - show time of day clock
                    phaseText = act.name;
                    displayText = formatTimeOfDay();
                    
                    // Round info
                    const rg = roundGroups[phase.roundGroupIndex];
                    if (rg) {
                        const audioStatus = (act.audioEnabled !== false) ? 'On' : 'Off';
                        const activityCounts = getActivityCounts(phase);
                        roundInfo.textContent = `${rg.name || 'Group'} ${phase.round} of ${rg.rounds} Activity ${activityCounts.currentActivity} of ${activityCounts.totalActivities} - ${act.name} | Audio: ${audioStatus}`;
                    }
                } else if (act.mode === 'time' || act.mode === 'amrap' || act.mode === 'emom') {
                    phaseText = act.name;
                    displayText = formatTime(currentTime);
                    
                    // Round info
                    const rg = roundGroups[phase.roundGroupIndex];
                    if (rg) {
                        const audioStatus = (act.audioEnabled !== false) ? 'On' : 'Off';
                        const activityCounts = getActivityCounts(phase);
                        roundInfo.textContent = `${rg.name || 'Group'} ${phase.round} of ${rg.rounds} Activity ${activityCounts.currentActivity} of ${activityCounts.totalActivities} - ${act.name} | Audio: ${audioStatus}`;
                    }
                } else {
                    phaseText = act.name;
                    displayText = formatTime(currentTime);
                    
                    // Round info
                    const rg = roundGroups[phase.roundGroupIndex];
                    if (rg) {
                        const audioStatus = (act.audioEnabled !== false) ? 'On' : 'Off';
                        const activityCounts = getActivityCounts(phase);
                        roundInfo.textContent = `${rg.name || 'Group'} ${phase.round} of ${rg.rounds} Activity ${activityCounts.currentActivity} of ${activityCounts.totalActivities} - ${act.name} | Audio: ${audioStatus}`;
                    }
                }
            } else if (phase.type === 'rest') {
                phaseText = 'Rest';
                displayText = formatTime(currentTime);
                
                // Round info
                const rg = roundGroups[phase.roundGroupIndex];
                if (rg) {
                    const audioStatus = (act.audioEnabled !== false) ? 'On' : 'Off';
                    const activityCounts = getActivityCounts(phase);
                    roundInfo.textContent = `${rg.name || 'Group'} ${phase.round} of ${rg.rounds} Activity ${activityCounts.currentActivity} of ${activityCounts.totalActivities} - ${act.name} | Audio: ${audioStatus}`;
                }
            }
            
            phaseLabel.textContent = phaseText;
            display.textContent = displayText;
            
            // Color coding for countdown timers
            if (phase.type !== 'prep') {
                display.classList.remove('warning', 'danger');
            }
            if (phase.duration > 0 && (phase.type === 'work' || phase.type === 'rest')) {
                const percentRemaining = currentTime / phase.duration;
                if (percentRemaining <= 0.1) {
                    display.classList.add('danger');
                } else if (percentRemaining <= 0.3) {
                    display.classList.add('warning');
                }
            }
            
            // Update segment times display for rep-based work phases
            updateSegmentTimesDisplay();
        }
        
        // Render activities
        function renderActivities() {
            roundGroupsContainer.innerHTML = '';
            
            roundGroups.forEach((rg, rgIndex) => {
                const rgCard = document.createElement('div');
                rgCard.className = 'round-group-card';
                var restRoundsVal = rg.restBetweenRounds || 0;
                var restRoundsStr = restRoundsVal >= 60 ? formatTime(restRoundsVal) : (restRoundsVal > 0 ? String(restRoundsVal) : '00:00');
                rgCard.innerHTML = `
                    <div class="round-group-header">
                        <input type="text" class="round-group-name" value="${rg.name || ''}" placeholder="Grouping Name" data-rg-index="${rgIndex}">
                        <button class="btn-remove" onclick="removeRoundGroup(${rgIndex})">Remove</button>
                    </div>
                    <div class="input-group" style="margin-bottom: 1rem;">
                        <label style="text-align: left;">Rounds (times to repeat this group)</label>
                        <div class="rounds-stepper">
                            <button type="button" class="stepper-btn rounds-adjust-btn" data-rg-index="${rgIndex}" data-field="rounds" data-dir="-1" aria-label="Decrease rounds">âˆ’</button>
                            <input type="text" class="custom-time-input" value="${rg.rounds || 1}" data-rg-index="${rgIndex}" data-field="rounds" aria-label="Number of rounds" style="max-width: 100px;">
                            <button type="button" class="stepper-btn rounds-adjust-btn" data-rg-index="${rgIndex}" data-field="rounds" data-dir="1" aria-label="Increase rounds">+</button>
                        </div>
                    </div>
                    <div class="input-group" style="margin-bottom: 1rem;">
                        <label style="text-align: left;">Rest Between Rounds (MM:SS)</label>
                        <div class="time-slider-wrap">
                            <input type="range" data-rg-index="${rgIndex}" data-field="restBetweenRounds" min="0" max="300" step="5" value="${Math.min(300, restRoundsVal)}" aria-label="Rest between rounds seconds">
                        </div>
                        <div class="time-stepper-row">
                            <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-field="restBetweenRounds" data-dir="-10" aria-label="Decrease rest 10s">âˆ’10</button>
                            <input type="text" class="custom-time-input" value="${restRoundsStr}" placeholder="00:00" data-rg-index="${rgIndex}" data-field="restBetweenRounds" aria-label="Rest between rounds">
                            <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-field="restBetweenRounds" data-dir="10" aria-label="Increase rest 10s">+10</button>
                        </div>
                    </div>
                    <div class="activities-container" data-rg-index="${rgIndex}"></div>
                    <button class="btn-add" onclick="addActivity(${rgIndex})" style="width: 100%; margin-top: 0.5rem;">+ Add Activity</button>
                `;
                roundGroupsContainer.appendChild(rgCard);
                
                const activitiesContainer = rgCard.querySelector('.activities-container');
                rg.activities.forEach((act, actIndex) => {
                    activitiesContainer.appendChild(createActivityCard(rgIndex, actIndex, act));
                });
                
                // Round group name input handler
                const nameInput = rgCard.querySelector('.round-group-name');
                nameInput.addEventListener('input', function() {
                    rg.name = this.value;
                    updateWorkoutSteps();
                });
                
                // Round group: rounds stepper
                const roundsInput = rgCard.querySelector('input[data-field="rounds"]');
                const roundsDecBtn = rgCard.querySelector('.rounds-stepper button[data-dir="-1"]');
                const roundsIncBtn = rgCard.querySelector('.rounds-stepper button[data-dir="1"]');
                if (roundsInput) {
                    roundsInput.addEventListener('input', function() {
                        rg.rounds = Math.max(1, Math.min(99, parseInt(this.value, 10) || 1));
                        this.value = rg.rounds;
                        updateWorkoutSteps();
                        updateButtonStates();
                    });
                }
                if (roundsDecBtn) {
                    roundsDecBtn.addEventListener('click', function() {
                        rg.rounds = Math.max(1, (rg.rounds || 1) - 1);
                        if (roundsInput) roundsInput.value = rg.rounds;
                        updateWorkoutSteps();
                        updateButtonStates();
                    });
                }
                if (roundsIncBtn) {
                    roundsIncBtn.addEventListener('click', function() {
                        rg.rounds = Math.min(99, (rg.rounds || 1) + 1);
                        if (roundsInput) roundsInput.value = rg.rounds;
                        updateWorkoutSteps();
                        updateButtonStates();
                    });
                }
                // Round group: rest between rounds slider + stepper
                const restRoundsSlider = rgCard.querySelector('input[type="range"][data-field="restBetweenRounds"]');
                const restRoundsTimeInput = rgCard.querySelector('.time-stepper-row input[data-field="restBetweenRounds"]');
                const restRoundsDecBtn = rgCard.querySelector('.time-stepper-row button[data-dir="-10"]');
                const restRoundsIncBtn = rgCard.querySelector('.time-stepper-row button[data-dir="10"]');
                function syncRestRoundsFromInput() {
                    var sec = parseTime(restRoundsTimeInput && restRoundsTimeInput.value ? restRoundsTimeInput.value : '0');
                    rg.restBetweenRounds = Math.min(300, sec);
                    if (restRoundsSlider) restRoundsSlider.value = rg.restBetweenRounds;
                    if (restRoundsTimeInput) restRoundsTimeInput.value = rg.restBetweenRounds >= 60 ? formatTime(rg.restBetweenRounds) : (rg.restBetweenRounds > 0 ? String(rg.restBetweenRounds) : '00:00');
                    updateWorkoutSteps();
                }
                function syncRestRoundsFromSlider() {
                    var sec = parseInt(restRoundsSlider && restRoundsSlider.value ? restRoundsSlider.value : 0, 10);
                    rg.restBetweenRounds = sec;
                    if (restRoundsTimeInput) restRoundsTimeInput.value = sec >= 60 ? formatTime(sec) : (sec > 0 ? String(sec) : '00:00');
                    updateWorkoutSteps();
                }
                if (restRoundsSlider) restRoundsSlider.addEventListener('input', syncRestRoundsFromSlider);
                if (restRoundsTimeInput) restRoundsTimeInput.addEventListener('input', syncRestRoundsFromInput);
                if (restRoundsDecBtn) restRoundsDecBtn.addEventListener('click', function() { var s = Math.max(0, (rg.restBetweenRounds || 0) - 10); rg.restBetweenRounds = s; if (restRoundsSlider) restRoundsSlider.value = s; if (restRoundsTimeInput) restRoundsTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00'); updateWorkoutSteps(); });
                if (restRoundsIncBtn) restRoundsIncBtn.addEventListener('click', function() { var s = Math.min(300, (rg.restBetweenRounds || 0) + 10); rg.restBetweenRounds = s; if (restRoundsSlider) restRoundsSlider.value = s; if (restRoundsTimeInput) restRoundsTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00'); updateWorkoutSteps(); });
            });
            
            updateWorkoutSteps();
            updateReminderDisplays();
        }
        
        function createActivityCard(rgIndex, actIndex, act) {
            var durVal = act.duration || 0;
            var durStr = durVal >= 60 ? formatTime(durVal) : (durVal > 0 ? String(durVal) : '00:00');
            var restVal = act.restBetweenActivities || 0;
            var restStr = restVal >= 60 ? formatTime(restVal) : (restVal > 0 ? String(restVal) : '00:00');
            const card = document.createElement('div');
            card.className = 'activity-card';
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <strong>Activity ${actIndex + 1}</strong>
                    <button class="btn-remove" onclick="removeActivity(${rgIndex}, ${actIndex})">Remove</button>
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Activity Name *</label>
                    <input type="text" value="${(act.name || '').replace(/"/g, '&quot;')}" placeholder="e.g., Pushups" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="name">
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Mode *</label>
                    <select data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="mode">
                        <option value="time" ${act.mode === 'time' ? 'selected' : ''}>Time-based</option>
                        <option value="rep" ${act.mode === 'rep' ? 'selected' : ''}>Rep-based</option>
                    </select>
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Duration (MM:SS)</label>
                    <div class="time-slider-wrap">
                        <input type="range" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="duration" min="0" max="600" step="5" value="${Math.min(600, durVal)}" aria-label="Duration seconds">
                    </div>
                    <div class="time-stepper-row">
                        <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="duration" data-dir="-10" aria-label="Decrease duration 10s">âˆ’10</button>
                        <input type="text" class="custom-time-input" value="${durStr}" placeholder="00:00" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="duration" aria-label="Duration">
                        <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="duration" data-dir="10" aria-label="Increase duration 10s">+10</button>
                    </div>
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Quantity / Reps Target</label>
                    <input type="number" value="${act.repsTarget || ''}" placeholder="0" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="repsTarget">
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Rest Between Activities (MM:SS)</label>
                    <div class="time-slider-wrap">
                        <input type="range" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="restBetweenActivities" min="0" max="300" step="5" value="${Math.min(300, restVal)}" aria-label="Rest between activities seconds">
                    </div>
                    <div class="time-stepper-row">
                        <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="restBetweenActivities" data-dir="-10" aria-label="Decrease rest 10s">âˆ’10</button>
                        <input type="text" class="custom-time-input" value="${restStr}" placeholder="00:00" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="restBetweenActivities" aria-label="Rest between activities">
                        <button type="button" class="stepper-btn" data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="restBetweenActivities" data-dir="10" aria-label="Increase rest 10s">+10</button>
                    </div>
                </div>
                <div class="input-group" style="display: flex; align-items: center; gap: 0.5rem;">
                    <label style="margin-bottom: 0; flex: 1; text-align: left;">Audio cues</label>
                    <input type="checkbox" ${(act.audioEnabled !== false) ? 'checked' : ''} data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="audioEnabled" style="width: auto; cursor: pointer;">
                </div>
                <div class="input-group">
                    <label style="text-align: left;">Notes / Cues</label>
                    <textarea placeholder="Optional notes..." data-rg-index="${rgIndex}" data-act-index="${actIndex}" data-field="notes">${(act.notes || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                </div>
            `;
            
            var rg = roundGroups[rgIndex];
            var a = rg && rg.activities && rg.activities[actIndex] ? rg.activities[actIndex] : act;
            function bindTimeField(fieldName, maxSec) {
                var slider = card.querySelector('input[type="range"][data-field="' + fieldName + '"]');
                var timeInput = card.querySelector('input.custom-time-input[data-field="' + fieldName + '"]');
                var row = timeInput ? timeInput.closest('.time-stepper-row') : null;
                var decBtn = row ? row.querySelector('button[data-dir="-10"]') : null;
                var incBtn = row ? row.querySelector('button[data-dir="10"]') : null;
                function updateModel(sec) {
                    a[fieldName] = Math.max(0, Math.min(maxSec, sec));
                    if (slider) slider.value = a[fieldName];
                    if (timeInput) timeInput.value = a[fieldName] >= 60 ? formatTime(a[fieldName]) : (a[fieldName] > 0 ? String(a[fieldName]) : '00:00');
                    updateWorkoutSteps();
                    updateButtonStates();
                }
                if (slider) slider.addEventListener('input', function() { updateModel(parseInt(this.value, 10) || 0); });
                if (timeInput) timeInput.addEventListener('input', function() { updateModel(parseTime(this.value) || 0); });
                if (decBtn) decBtn.addEventListener('click', function() { updateModel((a[fieldName] || 0) - 10); });
                if (incBtn) incBtn.addEventListener('click', function() { updateModel((a[fieldName] || 0) + 10); });
            }
            bindTimeField('duration', 600);
            bindTimeField('restBetweenActivities', 300);
            
            var inputs = card.querySelectorAll('input[data-field="name"], input[data-field="mode"], input[data-field="repsTarget"], input[data-field="audioEnabled"], select[data-field="mode"], textarea[data-field="notes"]');
            inputs.forEach(input => {
                if (input.type === 'range') return;
                const eventType = input.type === 'checkbox' ? 'change' : 'input';
                input.addEventListener(eventType, function() {
                    const rgIdx = parseInt(this.dataset.rgIndex);
                    const actIdx = parseInt(this.dataset.actIndex);
                    const field = this.dataset.field;
                    if (!field) return;
                    var target = roundGroups[rgIdx] && roundGroups[rgIdx].activities && roundGroups[rgIdx].activities[actIdx] ? roundGroups[rgIdx].activities[actIdx] : null;
                    if (!target) return;
                    if (field === 'audioEnabled') {
                        target[field] = this.checked;
                    } else if (field === 'repsTarget') {
                        target[field] = parseInt(this.value, 10) || 0;
                    } else if (field === 'name' || field === 'mode' || field === 'notes') {
                        target[field] = this.value;
                    }
                    updateWorkoutSteps();
                    updateButtonStates();
                });
            });
            
            return card;
        }
        
        function addRoundGroup() {
            roundGroups.push({
                id: generateId(),
                name: '',
                rounds: 1,
                restBetweenRounds: 0,
                activities: []
            });
            renderActivities();
            updateButtonStates();
        }
        
        function removeRoundGroup(rgIndex) {
            roundGroups.splice(rgIndex, 1);
            renderActivities();
            updateButtonStates();
        }
        
        function addActivity(rgIndex) {
            if (!roundGroups[rgIndex]) return;
            roundGroups[rgIndex].activities.push({
                name: '',
                mode: 'time',
                duration: 0,
                repsTarget: 0,
                restBetweenActivities: 0,
                notes: '',
                audioEnabled: true
            });
            renderActivities();
            updateButtonStates();
        }
        
        function removeActivity(rgIndex, actIndex) {
            if (!roundGroups[rgIndex] || !roundGroups[rgIndex].activities[actIndex]) return;
            roundGroups[rgIndex].activities.splice(actIndex, 1);
            renderActivities();
            updateButtonStates();
        }
        
        function updateWorkoutSteps() {
            workoutStepsList.innerHTML = '';
            
            if (roundGroups.length === 0) {
                workoutStepsContainer.style.display = 'none';
                return;
            }
            
            workoutStepsContainer.style.display = 'block';
            
            let sequentialNumber = 1; // Track sequential activity number across all rounds
            
            roundGroups.forEach((rg, rgIndex) => {
                const rgHeader = document.createElement('div');
                rgHeader.className = 'workout-step-item';
                rgHeader.style.fontWeight = '600';
                rgHeader.style.backgroundColor = 'rgba(var(--accent), 0.3)';
                rgHeader.textContent = `${rg.name || 'Group ' + (rgIndex + 1)} (${rg.rounds} rounds)`;
                workoutStepsList.appendChild(rgHeader);
                
                for (let round = 1; round <= rg.rounds; round++) {
                    rg.activities.forEach((act, actIndex) => {
                        const step = document.createElement('div');
                        step.className = 'workout-step-item';
                        step.style.display = 'flex';
                        step.style.justifyContent = 'space-between';
                        step.style.alignItems = 'flex-start';
                        
                        // Check for timestamp and rep-based segment times
                        const timestampEntry = getTimestampForStep(rgIndex, actIndex, round);
                        const segmentEntry = getRepBasedSegmentForStep(rgIndex, actIndex, round);
                        
                        // Get start timestamp for display
                        let startTimestamp = null;
                        if (act.mode === 'rep' && segmentEntry && segmentEntry.startTime) {
                            startTimestamp = segmentEntry.startTime;
                        } else if (timestampEntry) {
                            startTimestamp = timestampEntry.timestamp;
                        }
                        
                        // Build duration and start time display
                        let durationText = '';
                        if (act.mode === 'time' && act.duration > 0) {
                            durationText = `Duration: ${formatTime(act.duration)}`;
                        } else if (act.mode === 'rep' && act.repsTarget > 0) {
                            durationText = `Reps: ${act.repsTarget}`;
                        } else if ((act.mode === 'time' || act.mode === 'amrap' || act.mode === 'emom') && act.duration > 0) {
                            durationText = formatTime(act.duration);
                        }
                        
                        // Build details array for other info (rest, etc.)
                        let otherDetails = [];
                        if (act.restBetweenActivities > 0) otherDetails.push(`Rest: ${formatTime(act.restBetweenActivities)}`);
                        
                        // Build the details line with Duration/Reps and Start time
                        let detailsLine = [];
                        if (durationText) {
                            if (startTimestamp) {
                                const startTimeStr = act.mode === 'rep' && segmentEntry 
                                    ? formatTimeOfDayForDate(startTimestamp)
                                    : formatTimestamp(startTimestamp);
                                detailsLine.push(`${durationText} | Start: ${startTimeStr}`);
                            } else {
                                detailsLine.push(durationText);
                            }
                        } else if (startTimestamp) {
                            const startTimeStr = act.mode === 'rep' && segmentEntry 
                                ? formatTimeOfDayForDate(startTimestamp)
                                : formatTimestamp(startTimestamp);
                            detailsLine.push(`Start: ${startTimeStr}`);
                        }
                        if (otherDetails.length > 0) {
                            detailsLine.push(...otherDetails);
                        }
                        
                        // Build notes text (will be displayed in regular text, not bold)
                        // Truncate notes to 200 characters
                        let notesDisplay = act.notes && act.notes.trim() ? act.notes.trim() : '';
                        if (notesDisplay.length > 200) {
                            notesDisplay = notesDisplay.substring(0, 200) + '...';
                        }
                        const notesText = notesDisplay ? ` | Notes: ${notesDisplay}` : '';
                        
                        // Use sequential number instead of round number
                        // Split header and notes so notes are not bold
                        step.innerHTML = `
                            <div style="flex: 1; min-width: 0;">
                                <div class="workout-step-header">${sequentialNumber} - ${act.name || 'Unnamed'}</div>
                                <div class="workout-step-details">${detailsLine.join(' | ')}${notesText}</div>
                            </div>
                        `;
                        workoutStepsList.appendChild(step);
                        
                        // Increment sequential number for next activity
                        sequentialNumber++;
                    });
                }
            });
        }
        
        function updateButtonStates() {
            const isValid = hasValidTimerData();
            
            // Enable workout select when paused or stopped (allow workout changes)
            if (workoutSelect) {
                workoutSelect.disabled = isRunning && !isPaused;
            }
            const auditDisabled = isRunning || isPaused;
            if (enableTonesEl) enableTonesEl.disabled = auditDisabled;
            if (enableVoiceEl) enableVoiceEl.disabled = auditDisabled;
            if (enableHapticEl) enableHapticEl.disabled = auditDisabled;
            if (reminderMinutesRemainEl) reminderMinutesRemainEl.disabled = auditDisabled;
            if (reminder2MinEl) reminder2MinEl.disabled = auditDisabled;
            if (reminder1MinEl) reminder1MinEl.disabled = auditDisabled;
            if (prepTimeInput) prepTimeInput.disabled = auditDisabled;
            if (prepTimeSlider) prepTimeSlider.disabled = auditDisabled;
            if (prepTimeDecreaseBtn) prepTimeDecreaseBtn.disabled = auditDisabled;
            if (prepTimeIncreaseBtn) prepTimeIncreaseBtn.disabled = auditDisabled;
            if (prepPhaseLabelInput) prepPhaseLabelInput.disabled = auditDisabled;
            
            // Check if Complete/Next button should be visible
            let showCompleteNext = false;
            if (isRunning && !isPaused && currentWorkoutState) {
                const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                if (phase && phase.type === 'work' && phase.activity && phase.activity.mode === 'rep') {
                    showCompleteNext = true;
                }
            }
            completeNextBtn.style.display = showCompleteNext ? 'inline-block' : 'none';
            
            if (isRunning && !isPaused) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                resetBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
                setupBtn.style.display = 'none';
                repeatWorkoutBtn.style.display = 'none';
            } else if (isPaused) {
                // When paused, allow access to setup to change workouts
                startBtn.style.display = 'inline-block';
                startBtn.textContent = 'Resume';
                pauseBtn.style.display = 'none';
                resetBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
                setupBtn.style.display = 'inline-block';
                repeatWorkoutBtn.style.display = 'none';
            } else if (isArmed) {
                // Armed state - ready for next round
                startBtn.style.display = 'inline-block';
                startBtn.textContent = 'Start';
                pauseBtn.style.display = 'none';
                resetBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
                setupBtn.style.display = 'none';
                repeatWorkoutBtn.style.display = 'none';
            } else if (isWorkoutComplete) {
                // Workout complete state
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'none';
                repeatWorkoutBtn.style.display = 'inline-block';
                resetBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
                setupBtn.style.display = 'inline-block';
            } else {
                if (isValid) {
                    startBtn.style.display = 'inline-block';
                    startBtn.textContent = 'Start';
                    pauseBtn.style.display = 'none';
                    resetBtn.style.display = 'inline-block';
                    clearBtn.style.display = 'inline-block';
                    setupBtn.style.display = 'none';
                    repeatWorkoutBtn.style.display = 'none';
                } else {
                    startBtn.style.display = 'none';
                    pauseBtn.style.display = 'none';
                    resetBtn.style.display = 'none';
                    clearBtn.style.display = 'inline-block';
                    setupBtn.style.display = 'inline-block';
                    repeatWorkoutBtn.style.display = 'none';
                }
            }
            // Toggle 2Ã—2 layout when exactly 4 buttons visible (e.g. paused: Resume, Reset, Clear, Set Up)
            const controlContainer = document.getElementById('controlButtonsContainer');
            if (controlContainer) {
                const visibleCount = Array.from(controlContainer.querySelectorAll('.control-btn')).filter(function(b) { return getComputedStyle(b).display !== 'none'; }).length;
                controlContainer.classList.toggle('four-buttons', visibleCount === 4);
            }
        }
        
        // Timer functions
        function startTimer() {
            // Prevent multiple intervals
            if (timerInterval) {
                return;
            }
            
            // Prevent starting if workout is complete
            if (isWorkoutComplete) {
                return;
            }
            
            // If armed, start the next round
            if (isArmed && currentWorkoutState) {
                isArmed = false;
                isRunning = true;
                isPaused = false;
                
                const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                if (phase) {
                    currentTime = phase.duration;
                    // Initialize EMOM tracking if entering EMOM phase
                    if (phase.type === 'work' && phase.activity && phase.activity.mode === 'emom' && phase.duration > 0) {
                        emomTotalMinutes = Math.floor(phase.duration / 60);
                        emomCurrentMinute = 1;
                        emomSecondsInMinute = 60;
                        // Don't beep here - let the timer interval handle it when we're actually running
                    } else {
                        emomTotalMinutes = 0;
                        emomCurrentMinute = 1;
                        emomSecondsInMinute = 60;
                    }
                    // Record timestamp when Start button is pressed for next activity/round
                    recordStartTimestamp();
                }
                
                // Check if starting with a rep-based work phase and record start time
                checkAndRecordRepBasedStart();
                
                updateTimeOfDayInterval();
                updateDisplay();
                updateButtonStates();
                
                // Define timer function
                const timerTick = () => {
                    const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                    const act = phase && phase.activity;
                    const hasNoDuration = act && ((act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                          (phase.duration === 0 || phase.duration === null || phase.duration === undefined));
                    const isRepBasedWorkWithNoDuration = phase && phase.type === 'work' && 
                        act && act.mode === 'rep' && hasNoDuration;
                    
                    // Reset EMOM tracking if we're not in an EMOM work phase
                    const isEmomWorkPhase = phase && phase.type === 'work' && act && act.mode === 'emom';
                    if (!isEmomWorkPhase && emomTotalMinutes > 0) {
                        emomTotalMinutes = 0;
                        emomCurrentMinute = 1;
                        emomSecondsInMinute = 60;
                    }
                    
                    // For rep-based work with no duration, time of day is updated by separate interval
                    if (isRepBasedWorkWithNoDuration) {
                        return; // Time of day updates via timeOfDayInterval
                    }
                    
                    // Handle EMOM mode
                    const isEmom = phase && phase.type === 'work' && act && act.mode === 'emom' && emomTotalMinutes > 0;
                    if (isEmom) {
                        // Decrement seconds in current minute
                        if (emomSecondsInMinute > 0) {
                            emomSecondsInMinute--;
                        }
                        
                        // Beep when minute completes (at 0, moving to next minute)
                        if (emomSecondsInMinute <= 0) {
                            // Play minute start beep at the top of each new minute
                            if (emomCurrentMinute < emomTotalMinutes) {
                                playMinuteStartBeep(phase);
                                emomCurrentMinute++;
                                emomSecondsInMinute = 60;
                            } else {
                                // All minutes complete - phase is done
                                // Play three low tones if work phase is ending
                                const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                                if (completedPhase && completedPhase.type === 'work') {
                                    playThreeLowTones(completedPhase);
                                } else {
                                    playTransitionBeep(completedPhase);
                                }
                                
                                // Clear rep-based work tracking when leaving phase
                                updateTimeOfDayInterval();
                                
                                // Move to next phase
                                const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                                if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                                    // Workout complete
                                    if (completedPhase && completedPhase.type === 'work') {
                                        playThreeLowTones(completedPhase);
                                    } else {
                                        playTransitionBeep(completedPhase);
                                    }
                                    updateDisplay(); // Show 00:00 before completing
                                    handleWorkoutComplete();
                                    return;
                                }
                                
                                // Auto-advance to next phase (including across activity boundaries for mobility timer)
                                const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                                
                                // If rest phase just ended and next phase is work, play three chimes
                                if ((completedPhase.type === 'rest' || completedPhase.type === 'prep') && nextPhase && nextPhase.type === 'work') {
                                    playThreeChimes(nextPhase);
                                }
                                
                                currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                                currentTime = nextPhase.duration;
                                // Initialize EMOM tracking for next phase if applicable
                                if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                                    emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                                    emomCurrentMinute = 1;
                                    emomSecondsInMinute = 60;
                                    // Don't beep here - let timer interval handle it when we're actually in work phase
                                } else {
                                    emomTotalMinutes = 0;
                                    emomCurrentMinute = 1;
                                    emomSecondsInMinute = 60;
                                }
                                checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                                updateTimeOfDayInterval();
                                updateButtonStates();
                            }
                        }
                        
                        updateDisplay();
                        return;
                    }
                    
                    // Handle duration-based completion check
                    {
                        const currentPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                        if (currentPhase && currentPhase.type !== 'prep') {
                            const totalRem = getTotalRemaining();
                            const halfSec = Math.round(getTotalDuration() / 2);
                            let msg = null;
                            if (reminderMinutesRemainEl && reminderMinutesRemainEl.checked && !reminderFiredHalf && totalRem === halfSec) {
                                msg = (Math.round(totalRem / 60) === 1 ? '1 minute remaining' : Math.round(totalRem / 60) + ' minutes remaining');
                                reminderFiredHalf = true;
                            } else if (reminder2MinEl && reminder2MinEl.checked && !reminderFired2Min && totalRem === 120) {
                                msg = '2 minutes remaining';
                                reminderFired2Min = true;
                            } else if (reminder1MinEl && reminder1MinEl.checked && !reminderFired1Min && totalRem === 60) {
                                msg = '1 minute remains';
                                reminderFired1Min = true;
                            }
                            if (msg) {
                                if (enableTonesEl && enableTonesEl.checked) playDoubleBeep();
                                if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak(msg); }, 800);
                                if (enableHapticEl && enableHapticEl.checked) triggerHaptic('double');
                            }
                        }
                        // Play countdown beeps at 3, 2, 1 seconds
                        if (currentTime > 0 && currentTime <= 3) {
                            playCountdownBeep(currentPhase, currentTime);
                        }
                        
                        if (currentTime > 0) {
                            currentTime--;
                        }
                        
                        // Check if phase is complete
                        if (currentTime <= 0) {
                            // Play three low tones if work phase is ending, otherwise transition beep
                            const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                            if (completedPhase && completedPhase.type === 'work') {
                                playThreeLowTones(completedPhase);
                            } else {
                                playTransitionBeep(completedPhase);
                            }
                            
                            // Clear rep-based work tracking when leaving phase
                            updateTimeOfDayInterval();
                            
                            // Move to next phase
                            const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                            if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                                // Workout complete - play three low tones if work phase ending
                                if (completedPhase && completedPhase.type === 'work') {
                                    playThreeLowTones(completedPhase);
                                } else {
                                    playTransitionBeep(completedPhase);
                                }
                                updateDisplay(); // Show 00:00 before completing
                                handleWorkoutComplete();
                                return;
                            }
                            
                            // Auto-advance to next phase (including across activity boundaries for mobility timer)
                            const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                            
                            if ((completedPhase.type === 'rest' || completedPhase.type === 'prep') && nextPhase && nextPhase.type === 'work') {
                                playThreeChimes(nextPhase);
                            }
                            
                            currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                            currentTime = nextPhase.duration;
                            // Initialize EMOM tracking for next phase if applicable
                            if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                                emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                                // Don't beep here - let the timer interval handle it when we're actually in the work phase
                            } else {
                                emomTotalMinutes = 0;
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                            }
                            checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                            updateTimeOfDayInterval();
                            updateButtonStates();
                            
                            // IMPORTANT: After transitioning, check if the new phase is rep-based with no duration
                            // If so, return early to avoid immediately triggering another transition
                            const nextAct = nextPhase && nextPhase.activity;
                            const nextHasNoDuration = nextAct && ((nextAct.duration === 0 || nextAct.duration === null || nextAct.duration === undefined) || 
                                                  (nextPhase.duration === 0 || nextPhase.duration === null || nextPhase.duration === undefined));
                            const nextIsRepBasedWorkWithNoDuration = nextPhase && nextPhase.type === 'work' && 
                                nextAct && nextAct.mode === 'rep' && nextHasNoDuration;
                            if (nextIsRepBasedWorkWithNoDuration) {
                                updateDisplay();
                                return; // Time of day updates via timeOfDayInterval, don't continue countdown
                            }
                        }
                    }
                    
                    updateDisplay();
                };
                
                // Start interval - it will wait 1 second before first execution, which is correct
                timerInterval = setInterval(timerTick, 1000);
                return;
            }
            
            // Start new workout
            if (!hasValidTimerData()) {
                alert('Please configure a valid workout before starting.');
                return;
            }
            
            currentWorkoutState = buildWorkoutState();
            if (currentWorkoutState.phases.length === 0) {
                alert('No workout phases to run.');
                return;
            }
            
            currentWorkoutState.currentPhaseIndex = 0;
            const phase = currentWorkoutState.phases[0];
            currentTime = phase.duration;
            if (phase.type === 'prep' && phase.duration > 0 && enableVoiceEl && enableVoiceEl.checked) {
                setTimeout(function() { speak(phase.prepLabel || getPrepPhaseLabel()); }, 800);
            }
            // Initialize EMOM tracking if starting with EMOM phase
            if (phase.type === 'work' && phase.activity && phase.activity.mode === 'emom' && phase.duration > 0) {
                emomTotalMinutes = Math.floor(phase.duration / 60);
                emomCurrentMinute = 1;
                emomSecondsInMinute = 60;
                // Don't beep here - let the timer interval handle it when we're actually running
            } else {
                emomTotalMinutes = 0;
                emomCurrentMinute = 1;
                emomSecondsInMinute = 60;
            }
            workoutStartTime = Date.now();
            isRunning = true;
            isPaused = false;
            isArmed = false;
            reminderFiredHalf = false;
            reminderFired2Min = false;
            reminderFired1Min = false;
            
            // Record timestamp when Start button is pressed for initial workout
            recordStartTimestamp();
            
            // Check if starting with a rep-based work phase and record start time
            checkAndRecordRepBasedStart();
            
            updateTimeOfDayInterval();
            updateDisplay();
            updateButtonStates();
            
            // Define timer function
            const timerTick = () => {
                const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                const act = phase && phase.activity;
                const hasNoDuration = act && ((act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                      (phase.duration === 0 || phase.duration === null || phase.duration === undefined));
                const isRepBasedWorkWithNoDuration = phase && phase.type === 'work' && 
                    act && act.mode === 'rep' && hasNoDuration;
                
                // For rep-based work with no duration, time of day is updated by separate interval
                if (isRepBasedWorkWithNoDuration) {
                    return; // Time of day updates via timeOfDayInterval
                }
                
                // Handle EMOM mode
                const isEmom = phase && phase.type === 'work' && act && act.mode === 'emom' && emomTotalMinutes > 0;
                if (isEmom) {
                    // Decrement seconds in current minute
                    if (emomSecondsInMinute > 0) {
                        emomSecondsInMinute--;
                    }
                    
                    // When minute completes, move to next minute
                    if (emomSecondsInMinute <= 0) {
                        // Play minute start beep at the top of each new minute
                        if (emomCurrentMinute < emomTotalMinutes) {
                            playMinuteStartBeep(phase);
                            emomCurrentMinute++;
                            emomSecondsInMinute = 60;
                                } else {
                                    // All minutes complete - phase is done
                                    // Play three low tones if work phase is ending
                                    const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                            if (completedPhase && completedPhase.type === 'work') {
                                playThreeLowTones(completedPhase);
                            } else {
                                playTransitionBeep(completedPhase);
                            }
                            
                            // Clear rep-based work tracking when leaving phase
                            updateTimeOfDayInterval();
                            
                            // Move to next phase
                            const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                            if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                                // Workout complete
                                if (completedPhase && completedPhase.type === 'work') {
                                    playThreeLowTones(completedPhase);
                                } else {
                                    playTransitionBeep(completedPhase);
                                }
                                updateDisplay(); // Show 00:00 before completing
                                handleWorkoutComplete();
                                return;
                            }
                            
                            // Auto-advance to next phase (including across activity boundaries for mobility timer)
                            const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                            
                            if ((completedPhase.type === 'rest' || completedPhase.type === 'prep') && nextPhase && nextPhase.type === 'work') {
                                playThreeChimes(nextPhase);
                            }
                            
                            currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                            currentTime = nextPhase.duration;
                            // Initialize EMOM tracking for next phase if applicable
                            if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                                emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                                // Don't beep here - let the timer interval handle it when we're actually in the work phase
                            } else {
                                emomTotalMinutes = 0;
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                            }
                            checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                            updateTimeOfDayInterval();
                            updateButtonStates();
                        }
                    }
                    
                    updateDisplay();
                    return;
                }
                
                // Handle duration-based completion check
                {
                    const currentPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                    if (currentPhase && currentPhase.type !== 'prep') {
                        const totalRem = getTotalRemaining();
                        const halfSec = Math.round(getTotalDuration() / 2);
                        let msg = null;
                        if (reminderMinutesRemainEl && reminderMinutesRemainEl.checked && !reminderFiredHalf && totalRem === halfSec) {
                            msg = (Math.round(totalRem / 60) === 1 ? '1 minute remaining' : Math.round(totalRem / 60) + ' minutes remaining');
                            reminderFiredHalf = true;
                        } else if (reminder2MinEl && reminder2MinEl.checked && !reminderFired2Min && totalRem === 120) {
                            msg = '2 minutes remaining';
                            reminderFired2Min = true;
                        } else if (reminder1MinEl && reminder1MinEl.checked && !reminderFired1Min && totalRem === 60) {
                            msg = '1 minute remains';
                            reminderFired1Min = true;
                        }
                        if (msg) {
                            if (enableTonesEl && enableTonesEl.checked) playDoubleBeep();
                            if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak(msg); }, 800);
                            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('double');
                        }
                    }
                    if (currentTime > 0 && currentTime <= 3) {
                        playCountdownBeep(currentPhase, currentTime);
                    }
                    if (currentTime > 0) {
                        currentTime--;
                    }
                    if (currentTime <= 0) {
                        const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                        playTransitionBeep(completedPhase);
                        
                        // Clear rep-based work tracking when leaving phase
                        updateTimeOfDayInterval();
                        
                        // Move to next phase
                        const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                        if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                            // Workout complete - play transition sound for the last phase
                            playTransitionBeep(completedPhase);
                            updateDisplay(); // Show 00:00 before completing
                            handleWorkoutComplete();
                            return;
                        }
                        
                        // Auto-advance to next phase (including across activity boundaries for mobility timer)
                        const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                        currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                        
                        
                        currentTime = nextPhase.duration;
                        // Initialize EMOM tracking for next phase if applicable
                        if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                            emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                            emomCurrentMinute = 1;
                            emomSecondsInMinute = 60;
                            // Don't beep here - let timer interval handle it when we're actually in work phase
                        } else {
                            emomTotalMinutes = 0;
                            emomCurrentMinute = 1;
                            emomSecondsInMinute = 60;
                        }
                        checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                        updateTimeOfDayInterval();
                        updateButtonStates(); // Update button states when transitioning phases
                        
                        // IMPORTANT: After transitioning, check if the new phase is rep-based with no duration
                        // If so, return early to avoid immediately triggering another transition
                        const nextAct = nextPhase && nextPhase.activity;
                        const nextHasNoDuration = nextAct && ((nextAct.duration === 0 || nextAct.duration === null || nextAct.duration === undefined) || 
                                              (nextPhase.duration === 0 || nextPhase.duration === null || nextPhase.duration === undefined));
                        const nextIsRepBasedWorkWithNoDuration = nextPhase && nextPhase.type === 'work' && 
                            nextAct && nextAct.mode === 'rep' && nextHasNoDuration;
                        if (nextIsRepBasedWorkWithNoDuration) {
                            updateDisplay();
                            return; // Time of day updates via timeOfDayInterval, don't continue countdown
                        }
                    }
                }
                
                updateDisplay();
            };
            
            // Start interval - it will wait 1 second before first execution, which is correct
            // The display already shows the initial time (10 seconds), so we wait 1 second before decrementing
            timerInterval = setInterval(timerTick, 1000);
        }
        
        function pauseTimer() {
            primeSpeechForIOS();
            isRunning = false;
            isPaused = true;
            clearInterval(timerInterval);
            timerInterval = null;
            updateTimeOfDayInterval(); // This will clear the interval since we're paused
            if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Pause'); }, 800);
            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('long');
            updateButtonStates();
        }
        
        function resumeTimer() {
            primeSpeechForIOS();
            if (timerInterval) return;
            if (isPaused && currentWorkoutState) {
                ensureToneStarted().then(function() {
                    if (enableTonesEl && enableTonesEl.checked) playBeepShort();
                    if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Resume'); }, 800);
                    if (enableHapticEl && enableHapticEl.checked) triggerHaptic('short');
                    isRunning = true;
                    isPaused = false;
                    updateTimeOfDayInterval();
                
                // Define timer function
                const timerTick = () => {
                    const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                    const act = phase && phase.activity;
                    const hasNoDuration = act && ((act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                          (phase.duration === 0 || phase.duration === null || phase.duration === undefined));
                    const isRepBasedWorkWithNoDuration = phase && phase.type === 'work' && 
                        act && act.mode === 'rep' && hasNoDuration;
                    
                    // Reset EMOM tracking if we're not in an EMOM work phase
                    const isEmomWorkPhase = phase && phase.type === 'work' && act && act.mode === 'emom';
                    if (!isEmomWorkPhase && emomTotalMinutes > 0) {
                        emomTotalMinutes = 0;
                        emomCurrentMinute = 1;
                        emomSecondsInMinute = 60;
                    }
                    
                    // For rep-based work with no duration, time of day is updated by separate interval
                    if (isRepBasedWorkWithNoDuration) {
                        return; // Time of day updates via timeOfDayInterval
                    }
                    
                    // Handle EMOM mode
                    const isEmom = phase && phase.type === 'work' && act && act.mode === 'emom' && emomTotalMinutes > 0;
                    if (isEmom) {
                        // Decrement seconds in current minute
                        if (emomSecondsInMinute > 0) {
                            emomSecondsInMinute--;
                        }
                        
                        // Beep when minute completes (at 0, moving to next minute)
                        if (emomSecondsInMinute <= 0) {
                            // Play minute start beep at the top of each new minute
                            if (emomCurrentMinute < emomTotalMinutes) {
                                playMinuteStartBeep(phase);
                                emomCurrentMinute++;
                                emomSecondsInMinute = 60;
                            } else {
                                // All minutes complete - phase is done
                                // Play three low tones if work phase is ending
                                const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                                if (completedPhase && completedPhase.type === 'work') {
                                    playThreeLowTones(completedPhase);
                                } else {
                                    playTransitionBeep(completedPhase);
                                }
                                
                                // Clear rep-based work tracking when leaving phase
                                updateTimeOfDayInterval();
                                
                                // Move to next phase
                                const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                                if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                                    // Workout complete
                                    if (completedPhase && completedPhase.type === 'work') {
                                        playThreeLowTones(completedPhase);
                                    } else {
                                        playTransitionBeep(completedPhase);
                                    }
                                    updateDisplay(); // Show 00:00 before completing
                                    handleWorkoutComplete();
                                    return;
                                }
                                
                                // Auto-advance to next phase (including across activity boundaries for mobility timer)
                                const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                                
                                // If rest phase just ended and next phase is work, play three chimes
                                if ((completedPhase.type === 'rest' || completedPhase.type === 'prep') && nextPhase && nextPhase.type === 'work') {
                                    playThreeChimes(nextPhase);
                                }
                                
                                currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                                currentTime = nextPhase.duration;
                                // Initialize EMOM tracking for next phase if applicable
                                if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                                    emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                                    emomCurrentMinute = 1;
                                    emomSecondsInMinute = 60;
                                    // Don't beep here - let timer interval handle it when we're actually in work phase
                                } else {
                                    emomTotalMinutes = 0;
                                    emomCurrentMinute = 1;
                                    emomSecondsInMinute = 60;
                                }
                                checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                                updateTimeOfDayInterval();
                                updateButtonStates();
                            }
                        }
                        
                        updateDisplay();
                        return;
                    }
                    
                    // Handle duration-based completion check
                    {
                        const currentPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                        if (currentPhase && currentPhase.type !== 'prep') {
                            const totalRem = getTotalRemaining();
                            const halfSec = Math.round(getTotalDuration() / 2);
                            let msg = null;
                            if (reminderMinutesRemainEl && reminderMinutesRemainEl.checked && !reminderFiredHalf && totalRem === halfSec) {
                                msg = (Math.round(totalRem / 60) === 1 ? '1 minute remaining' : Math.round(totalRem / 60) + ' minutes remaining');
                                reminderFiredHalf = true;
                            } else if (reminder2MinEl && reminder2MinEl.checked && !reminderFired2Min && totalRem === 120) {
                                msg = '2 minutes remaining';
                                reminderFired2Min = true;
                            } else if (reminder1MinEl && reminder1MinEl.checked && !reminderFired1Min && totalRem === 60) {
                                msg = '1 minute remains';
                                reminderFired1Min = true;
                            }
                            if (msg) {
                                if (enableTonesEl && enableTonesEl.checked) playDoubleBeep();
                                if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak(msg); }, 800);
                                if (enableHapticEl && enableHapticEl.checked) triggerHaptic('double');
                            }
                        }
                        // Play countdown beeps at 3, 2, 1 seconds
                        if (currentTime > 0 && currentTime <= 3) {
                            playCountdownBeep(currentPhase, currentTime);
                        }
                        
                        if (currentTime > 0) {
                            currentTime--;
                        }
                        
                        // Check if phase is complete
                        if (currentTime <= 0) {
                            // Play three low tones if work phase is ending, otherwise transition beep
                            const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                            if (completedPhase && completedPhase.type === 'work') {
                                playThreeLowTones(completedPhase);
                            } else {
                                playTransitionBeep(completedPhase);
                            }
                            
                            // Clear rep-based work tracking when leaving phase
                            updateTimeOfDayInterval();
                            
                            // Move to next phase
                            const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                            if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                                // Workout complete - play three low tones if work phase ending
                                if (completedPhase && completedPhase.type === 'work') {
                                    playThreeLowTones(completedPhase);
                                } else {
                                    playTransitionBeep(completedPhase);
                                }
                                updateDisplay(); // Show 00:00 before completing
                                handleWorkoutComplete();
                                return;
                            }
                            
                            // Auto-advance to next phase (including across activity boundaries for mobility timer)
                            const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                            
                            if ((completedPhase.type === 'rest' || completedPhase.type === 'prep') && nextPhase && nextPhase.type === 'work') {
                                playThreeChimes(nextPhase);
                            }
                            
                            currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                            currentTime = nextPhase.duration;
                            // Initialize EMOM tracking for next phase if applicable
                            if (nextPhase.type === 'work' && nextPhase.activity && nextPhase.activity.mode === 'emom' && nextPhase.duration > 0) {
                                emomTotalMinutes = Math.floor(nextPhase.duration / 60);
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                                // Don't beep here - let the timer interval handle it when we're actually in the work phase
                            } else {
                                emomTotalMinutes = 0;
                                emomCurrentMinute = 1;
                                emomSecondsInMinute = 60;
                            }
                            checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                            updateTimeOfDayInterval();
                            updateButtonStates();
                            
                            // IMPORTANT: After transitioning, check if the new phase is rep-based with no duration
                            // If so, return early to avoid immediately triggering another transition
                            const nextAct = nextPhase && nextPhase.activity;
                            const nextHasNoDuration = nextAct && ((nextAct.duration === 0 || nextAct.duration === null || nextAct.duration === undefined) || 
                                                  (nextPhase.duration === 0 || nextPhase.duration === null || nextPhase.duration === undefined));
                            const nextIsRepBasedWorkWithNoDuration = nextPhase && nextPhase.type === 'work' && 
                                nextAct && nextAct.mode === 'rep' && nextHasNoDuration;
                            if (nextIsRepBasedWorkWithNoDuration) {
                                updateDisplay();
                                return; // Time of day updates via timeOfDayInterval, don't continue countdown
                            }
                        }
                    }
                    
                    updateDisplay();
                };
                
                // Start interval - it will wait 1 second before first execution, which is correct
                timerInterval = setInterval(timerTick, 1000);
                updateButtonStates();
                });
            }
        }
        
        function handleWorkoutComplete() {
            // Mark workout as complete
            isWorkoutComplete = true;
            isRunning = false;
            isPaused = false;
            isArmed = false;
            
            // Stop all timers
            clearInterval(timerInterval);
            timerInterval = null;
            if (timeOfDayInterval) {
                clearInterval(timeOfDayInterval);
                timeOfDayInterval = null;
            }
            
            // Update display and buttons
            updateDisplay();
            updateButtonStates();
        }
        
        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
            if (timeOfDayInterval) {
                clearInterval(timeOfDayInterval);
                timeOfDayInterval = null;
            }
            isRunning = false;
            isPaused = false;
            isArmed = false;
            updateButtonStates();
        }
        
        function completeNextRound() {
            if (!currentWorkoutState || !isRunning) return;
            
            const currentPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!currentPhase || currentPhase.type !== 'work' || currentPhase.activity.mode !== 'rep') {
                return; // Not a rep-based work phase
            }
            
            // Stop the current timer
            clearInterval(timerInterval);
            timerInterval = null;
            
            // Record stop time for this rep-based segment
            recordRepBasedSegmentStop();
            
            // Play three low tones if work phase is ending
            if (currentPhase && currentPhase.type === 'work') {
                playThreeLowTones(currentPhase);
            } else {
                playTransitionBeep(currentPhase);
            }
            
            // Move to next phase
            const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
            if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                // Workout complete
                updateDisplay(); // Show 00:00 before completing
                handleWorkoutComplete();
                return;
            }
            
            // Auto-advance to next phase (including across activity boundaries for mobility timer)
            const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
            currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
            currentTime = nextPhase.duration;
            
            // Update time of day interval when leaving phase
            updateTimeOfDayInterval();
            
            // Continue running the timer for the rest phase
            updateDisplay();
            updateButtonStates();
            
            timerInterval = setInterval(() => {
                const phase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                const act = phase && phase.activity;
                const hasNoDuration = act && ((act.duration === 0 || act.duration === null || act.duration === undefined) || 
                                      (phase.duration === 0 || phase.duration === null || phase.duration === undefined));
                const isRepBasedWorkWithNoDuration = phase && phase.type === 'work' && 
                    act && act.mode === 'rep' && hasNoDuration;
                
                // For rep-based work with no duration, time of day is updated by separate interval
                if (isRepBasedWorkWithNoDuration) {
                    return; // Time of day updates via timeOfDayInterval
                }
                
                // Handle duration-based completion check
                {
                    const currentPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                    if (currentPhase && currentPhase.type !== 'prep') {
                        const totalRem = getTotalRemaining();
                        const halfSec = Math.round(getTotalDuration() / 2);
                        let msg = null;
                        if (reminderMinutesRemainEl && reminderMinutesRemainEl.checked && !reminderFiredHalf && totalRem === halfSec) {
                            msg = (Math.round(totalRem / 60) === 1 ? '1 minute remaining' : Math.round(totalRem / 60) + ' minutes remaining');
                            reminderFiredHalf = true;
                        } else if (reminder2MinEl && reminder2MinEl.checked && !reminderFired2Min && totalRem === 120) {
                            msg = '2 minutes remaining';
                            reminderFired2Min = true;
                        } else if (reminder1MinEl && reminder1MinEl.checked && !reminderFired1Min && totalRem === 60) {
                            msg = '1 minute remains';
                            reminderFired1Min = true;
                        }
                        if (msg) {
                            if (enableTonesEl && enableTonesEl.checked) playDoubleBeep();
                            if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak(msg); }, 800);
                            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('double');
                        }
                    }
                    if (currentTime > 0 && currentTime <= 3) {
                        playCountdownBeep(currentPhase, currentTime);
                    }
                    if (currentTime > 0) {
                        currentTime--;
                    }
                    if (currentTime <= 0) {
                        const completedPhase = currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
                        playTransitionBeep(completedPhase);
                        
                        // Clear rep-based work tracking when leaving phase
                        updateTimeOfDayInterval();
                        
                        // Move to next phase
                        const nextPhaseIndex = currentWorkoutState.currentPhaseIndex + 1;
                        if (nextPhaseIndex >= currentWorkoutState.phases.length) {
                            // Workout complete
                            updateDisplay(); // Show 00:00 before completing
                            handleWorkoutComplete();
                            return;
                        }
                        
                        // Auto-advance to next phase (including across activity boundaries for mobility timer)
                        const nextPhase = currentWorkoutState.phases[nextPhaseIndex];
                        currentWorkoutState.currentPhaseIndex = nextPhaseIndex;
                        currentTime = nextPhase.duration;
                        
                        // If rest phase just ended and next phase is work, play three chimes
                        if (phase.type === 'rest' && nextPhase && nextPhase.type === 'work') {
                            playThreeChimes(phase);
                        }
                        
                        checkAndRecordRepBasedStart(); // Record start time if entering rep-based work phase
                        updateTimeOfDayInterval();
                        updateButtonStates(); // Update button states when transitioning phases
                        
                        // IMPORTANT: After transitioning, check if the new phase is rep-based with no duration
                        // If so, return early to avoid immediately triggering another transition
                        const nextAct = nextPhase && nextPhase.activity;
                        const nextHasNoDuration = nextAct && ((nextAct.duration === 0 || nextAct.duration === null || nextAct.duration === undefined) || 
                                              (nextPhase.duration === 0 || nextPhase.duration === null || nextPhase.duration === undefined));
                        const nextIsRepBasedWorkWithNoDuration = nextPhase && nextPhase.type === 'work' && 
                            nextAct && nextAct.mode === 'rep' && nextHasNoDuration;
                        if (nextIsRepBasedWorkWithNoDuration) {
                            updateDisplay();
                            return; // Time of day updates via timeOfDayInterval, don't continue countdown
                        }
                    }
                }
                
                updateDisplay();
            }, 1000);
        }
        
        function resetTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
            if (timeOfDayInterval) {
                clearInterval(timeOfDayInterval);
                timeOfDayInterval = null;
            }
            isRunning = false;
            isPaused = false;
            isArmed = false;
            isWorkoutComplete = false;
            currentWorkoutState = null;
            currentTime = 0;
            workoutStartTime = null;
            startTimestamps = [];
            repBasedSegmentTimes = [];
            updateWorkoutSteps(); // Refresh workout steps to remove timestamps
            updateDisplay();
            updateButtonStates();
            
            // Reset dropdown to 'custom' if a workout was selected to avoid confusion
            // This ensures the dropdown matches the timer state (no workout running)
            if (workoutSelect && workoutSelect.value !== 'custom') {
                workoutSelect.value = 'custom';
            }
        }
        
        function repeatWorkout() {
            if (!currentWorkoutState) {
                alert('No workout to repeat. Please set up a workout first.');
                return;
            }
            
            // Reset workout state but keep the workout configuration
            isWorkoutComplete = false;
            isRunning = false;
            isPaused = false;
            isArmed = false;
            currentTime = 0;
            workoutStartTime = null;
            
            // Clear timestamps and segment times for fresh start
            startTimestamps = [];
            repBasedSegmentTimes = [];
            
            // Rebuild workout state
            currentWorkoutState = buildWorkoutState();
            if (currentWorkoutState.phases.length === 0) {
                alert('No workout phases to run.');
                return;
            }
            
            // Reset to first phase
            currentWorkoutState.currentPhaseIndex = 0;
            const phase = currentWorkoutState.phases[0];
            currentTime = phase.duration;
            
            // Update displays
            updateWorkoutSteps();
            updateDisplay();
            updateButtonStates();
            
            // Auto-start the workout
            startTimer();
        }
        
        function clearTimer() {
            resetTimer();
            // Reset dropdown to 'custom' and clear all settings
            if (workoutSelect) {
                workoutSelect.value = 'custom';
            }
            loadMobilityWorkout('custom');
        }
        
        function activityAudioEnabled(phase) {
            if (!phase || !phase.activity) return true;
            return phase.activity.audioEnabled !== false;
        }
        
        function playSound(phase = null) {
            if (!activityAudioEnabled(phase)) return;
            if (!enableTonesEl || !enableTonesEl.checked) return;
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) { /* ignore */ }
        }
        
        function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; }
        function isSafari() { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); }
        
        function triggerHaptic(style) {
            style = style || 'short';
            if (!enableHapticEl || !enableHapticEl.checked) return;
            if (isIOS() && isSafari()) {
                const input = document.getElementById('haptic-switch');
                const label = document.getElementById('haptic-label');
                if (!input || !label) return;
                const toggle = function() { input.checked = !input.checked; label.click(); };
                if (style === 'short') toggle();
                else if (style === 'double') { toggle(); setTimeout(toggle, 80); }
                else if (style === 'long') { toggle(); setTimeout(toggle, 100); setTimeout(toggle, 200); }
                else if (style === 'complete') { toggle(); setTimeout(toggle, 60); setTimeout(toggle, 120); setTimeout(toggle, 180); }
            } else if (navigator.vibrate) {
                if (style === 'short') navigator.vibrate(50);
                else if (style === 'double') navigator.vibrate([50, 30, 50]);
                else if (style === 'long') navigator.vibrate(150);
                else if (style === 'complete') navigator.vibrate([100, 50, 100, 50, 100]);
            }
        }
        
        let audioStarted = false;
        function ensureToneStarted() {
            if (audioStarted || typeof Tone === 'undefined') return Promise.resolve();
            if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state === 'suspended') Tone.context.resume();
            return Tone.start().then(function() {
                audioStarted = true;
                const banner = document.getElementById('iosSoundBanner');
                if (banner) banner.style.display = 'none';
            });
        }
        function unlockAudioForIOS() {
            if (typeof Tone === 'undefined') return;
            const banner = document.getElementById('iosSoundBanner');
            if (banner) banner.style.display = 'none';
            if (Tone.context && Tone.context.state === 'suspended') Tone.context.resume();
            Tone.start().then(function() {
                audioStarted = true;
                if (enableTonesEl && enableTonesEl.checked) playBeepShort();
                updateDisplay();
            }).catch(function() { updateDisplay(); });
            primeSpeechForIOS();
        }
        function dismissIOSSoundBannerSilent() {
            const banner = document.getElementById('iosSoundBanner');
            if (banner) { banner.classList.add('hidden'); banner.style.display = 'none'; }
        }
        
        function playBeepShort() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            try {
                const synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                synth.triggerAttackRelease('A5', '16n');
            } catch (e) {}
        }
        function playWorkStartChime() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            try {
                const fmSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.5 } }).toDestination();
                fmSynth.triggerAttackRelease('C5', '8n');
            } catch (e) {}
        }
        function playRestStartTone() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            try {
                const synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.3 } }).toDestination();
                synth.triggerAttackRelease('A4', '8n');
            } catch (e) {}
        }
        function playWorkoutCompleteFanfare() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            try {
                const synth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
                const seq = new Tone.Sequence(function(time, note) { synth.triggerAttackRelease(note, '16n', time); }, ['C5', 'E5', 'G5'], '16n').start(0);
                seq.loop = false;
                Tone.Transport.start();
                setTimeout(function() { Tone.Transport.stop(); }, 500);
            } catch (e) {}
        }
        function playThreeBeeps() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            playBeepShort();
            setTimeout(playBeepShort, 1000);
            setTimeout(playBeepShort, 2000);
        }
        function playDoubleBeep() {
            if (!enableTonesEl || !enableTonesEl.checked || !audioStarted || typeof Tone === 'undefined') return;
            playBeepShort();
            setTimeout(playBeepShort, 150);
        }
        
        const speechSynth = window.speechSynthesis;
        let speechVoices = [];
        let defaultSpeechVoice = null;
        let speechPrimed = false;
        function populateVoices() {
            speechVoices = speechSynth.getVoices();
            defaultSpeechVoice = speechVoices.find(function(v) { return v.lang === 'en-US' && (v.name.indexOf('Samantha') !== -1 || (v.voiceURI && v.voiceURI.indexOf('Samantha') !== -1)); });
            if (!defaultSpeechVoice) defaultSpeechVoice = speechVoices.find(function(v) { return v.lang === 'en-US'; });
        }
        if (speechSynth.onvoiceschanged !== undefined) speechSynth.onvoiceschanged = populateVoices;
        populateVoices();
        function primeSpeechForIOS() {
            if (speechPrimed || !enableVoiceEl || !enableVoiceEl.checked) return;
            try {
                speechSynth.cancel();
                speechSynth.speak(new SpeechSynthesisUtterance(''));
                speechPrimed = true;
            } catch (e) {}
        }
        function speak(text) {
            if (!enableVoiceEl || !enableVoiceEl.checked || !text) return;
            if (speechSynth.speaking) speechSynth.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            if (defaultSpeechVoice) utterance.voice = defaultSpeechVoice;
            utterance.rate = 1.1;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            speechSynth.speak(utterance);
        }
        
        // Play a short beep for countdown (3, 2, 1 seconds)
        function playCountdownBeep(phase = null, countdownValue = null) {
            if (!activityAudioEnabled(phase)) return;
            const now = Date.now();
            const checkPhase = phase || (currentWorkoutState && currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex]);
            const phaseId = checkPhase ? `${checkPhase.type}-${currentWorkoutState ? currentWorkoutState.currentPhaseIndex : 'unknown'}` : 'unknown';
            const beepKey = `countdown-${phaseId}-${countdownValue !== null ? countdownValue : 'unknown'}`;
            if (lastBeepTime[beepKey] && (now - lastBeepTime[beepKey]) < 800) return;
            lastBeepTime[beepKey] = now;
            Object.keys(lastBeepTime).forEach(key => { if (now - lastBeepTime[key] > 2000) delete lastBeepTime[key]; });
            playBeepShort();
            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('short');
        }
        
        // Play work start cues (chime + "Work" + haptic) - after rest or at workout start
        function playThreeChimes(phase = null) {
            if (!activityAudioEnabled(phase)) return;
            const now = Date.now();
            const checkPhase = phase || (currentWorkoutState && currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex]);
            const phaseId = checkPhase ? `${checkPhase.type}-${currentWorkoutState ? currentWorkoutState.currentPhaseIndex : 'unknown'}` : 'unknown';
            const beepKey = `threechimes-${phaseId}`;
            if (lastBeepTime[beepKey] && (now - lastBeepTime[beepKey]) < 2000) return;
            lastBeepTime[beepKey] = now;
            Object.keys(lastBeepTime).forEach(key => { if (now - lastBeepTime[key] > 2000) delete lastBeepTime[key]; });
            playWorkStartChime();
            if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Work'); }, 800);
            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('short');
        }
        
        // Play transition cues: workâ†’rest, workâ†’work, workâ†’complete, or restâ†’work
        function playPhaseTransitionCues(completedPhase, nextPhase) {
            if (!activityAudioEnabled(completedPhase)) return;
            const now = Date.now();
            const phaseId = completedPhase ? `${completedPhase.type}-${currentWorkoutState ? currentWorkoutState.currentPhaseIndex : 'unknown'}` : 'unknown';
            const beepKey = `transition-${phaseId}`;
            if (lastBeepTime[beepKey] && (now - lastBeepTime[beepKey]) < 2000) return;
            lastBeepTime[beepKey] = now;
            Object.keys(lastBeepTime).forEach(key => { if (now - lastBeepTime[key] > 2000) delete lastBeepTime[key]; });
            if (!nextPhase) {
                if (enableTonesEl && enableTonesEl.checked) { playWorkoutCompleteFanfare(); playThreeBeeps(); } else playSound();
                const msg = completionMessageInput ? (completionMessageInput.value.trim() || 'Completed') : 'Completed';
                if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak(msg); }, 800);
                if (enableHapticEl && enableHapticEl.checked) triggerHaptic('complete');
            } else if (nextPhase.type === 'rest') {
                if (activityAudioEnabled(nextPhase)) {
                    if (enableTonesEl && enableTonesEl.checked) playRestStartTone(); else playSound();
                    if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Rest'); }, 800);
                    if (enableHapticEl && enableHapticEl.checked) triggerHaptic('double');
                }
            } else if (nextPhase.type === 'work') {
                if (activityAudioEnabled(nextPhase)) {
                    if (enableTonesEl && enableTonesEl.checked) playWorkStartChime(); else playSound();
                    if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Work'); }, 800);
                    if (enableHapticEl && enableHapticEl.checked) triggerHaptic('short');
                }
            }
        }
        
        function playThreeLowTones(phase) {
            if (!phase) return;
            const nextIdx = currentWorkoutState ? currentWorkoutState.currentPhaseIndex + 1 : 0;
            const nextPhase = currentWorkoutState && nextIdx < currentWorkoutState.phases.length ? currentWorkoutState.phases[nextIdx] : null;
            playPhaseTransitionCues(phase, nextPhase);
        }
        
        function playTransitionBeep(phase) {
            if (!phase) return;
            const nextIdx = currentWorkoutState ? currentWorkoutState.currentPhaseIndex + 1 : 0;
            const nextPhase = currentWorkoutState && nextIdx < currentWorkoutState.phases.length ? currentWorkoutState.phases[nextIdx] : null;
            playPhaseTransitionCues(phase, nextPhase);
        }
        
        // Play EMOM minute start cues (chime + "Work" + haptic)
        function playMinuteStartBeep(phase = null) {
            if (!isRunning || isPaused) return;
            if (!currentWorkoutState) return;
            const currentPhase = phase || currentWorkoutState.phases[currentWorkoutState.currentPhaseIndex];
            if (!currentPhase || currentPhase.type !== 'work' || !currentPhase.activity || currentPhase.activity.mode !== 'emom') return;
            if (!activityAudioEnabled(currentPhase)) return;
            const now = Date.now();
            const phaseId = `${currentPhase.roundGroupIndex}-${currentPhase.activityIndex}-${currentPhase.round}`;
            const beepKey = `minutestart-${phaseId}-${emomCurrentMinute}`;
            if (lastBeepTime[beepKey] && (now - lastBeepTime[beepKey]) < 2000) return;
            lastBeepTime[beepKey] = now;
            Object.keys(lastBeepTime).forEach(key => { if (now - lastBeepTime[key] > 5000) delete lastBeepTime[key]; });
            playWorkStartChime();
            if (enableVoiceEl && enableVoiceEl.checked) setTimeout(function() { speak('Work'); }, 800);
            if (enableHapticEl && enableHapticEl.checked) triggerHaptic('short');
        }
        
        // Export/Import
        function exportWorkout() {
            const workoutTitle = workoutTitleInput.value.trim() || 'workout';
            const workoutDescription = workoutDescriptionInput ? workoutDescriptionInput.value.trim() : '';
            const completionMessage = completionMessageInput ? (completionMessageInput.value.trim() || 'Completed') : 'Completed';
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `${workoutTitle}_${timestamp}.json`;
            
            const data = {
                title: workoutTitle,
                description: workoutDescription,
                completionMessage: completionMessage,
                roundGroups: roundGroups,
                enableTones: !!(enableTonesEl && enableTonesEl.checked),
                enableVoice: !!(enableVoiceEl && enableVoiceEl.checked),
                enableHaptic: !!(enableHapticEl && enableHapticEl.checked),
                exportedAt: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function importWorkout() {
            importFileInput.click();
        }
        
        importFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.roundGroups) {
                        roundGroups = data.roundGroups;
                        // Default missing audioEnabled to true for backward compatibility
                        roundGroups.forEach(rg => {
                            if (rg.activities) {
                                rg.activities.forEach(act => {
                                    if (act.audioEnabled === undefined) {
                                        act.audioEnabled = true;
                                    }
                                });
                            }
                        });
                        if (data.title) {
                            workoutTitleInput.value = data.title;
                        }
                        if (data.description && workoutDescriptionInput) {
                            workoutDescriptionInput.value = data.description;
                        }
                        if (completionMessageInput) {
                            completionMessageInput.value = (data.completionMessage && data.completionMessage.trim()) ? data.completionMessage.trim() : 'Completed';
                        }
                        if (enableTonesEl != null && data.enableTones !== undefined) enableTonesEl.checked = !!data.enableTones;
                        if (enableVoiceEl != null && data.enableVoice !== undefined) enableVoiceEl.checked = !!data.enableVoice;
                        if (enableHapticEl != null && data.enableHaptic !== undefined) enableHapticEl.checked = !!data.enableHaptic;
                        try { if (data.enableTones !== undefined) localStorage.setItem('enableTones', enableTonesEl.checked); } catch (e) {}
                        try { if (data.enableVoice !== undefined) localStorage.setItem('enableVoice', enableVoiceEl.checked); } catch (e) {}
                        try { if (data.enableHaptic !== undefined) localStorage.setItem('enableHaptic', enableHapticEl.checked); } catch (e) {}
                        unlockAudioForIOS();
                        updateCharCounts();
                        updateWorkoutDisplay();
                        renderActivities();
                        updateWorkoutSteps();
                        updateButtonStates();
                        updateDisplay();
                    } else {
                        alert('Invalid workout file format.');
                    }
                } catch (err) {
                    alert('Error importing workout: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });
        
        // Update workout title and description display (title in workout area on load, match countdown model)
        const DEFAULT_TIMER_NAME = 'Mobility';
        function updateWorkoutDisplay() {
            const title = workoutTitleInput.value.trim();
            const description = workoutDescriptionInput ? workoutDescriptionInput.value.trim() : '';
            
            // Update title display in timer block: show default timer name when no custom title
            if (workoutTitleText && workoutTitleDisplayBlock) {
                const displayTitle = title || DEFAULT_TIMER_NAME;
                const truncatedTitle = displayTitle.length > 40 ? displayTitle.substring(0, 40) + '...' : displayTitle;
                workoutTitleText.textContent = truncatedTitle;
                workoutTitleDisplayBlock.style.display = 'block';
            }
            
            // Description is only shown in slide panel, not on main timer page
            // Notes are already limited to 200 characters via maxlength attribute
        }
        
        // Update character counts
        function updateCharCounts() {
            if (workoutTitleCharCount && workoutTitleInput) {
                workoutTitleCharCount.textContent = workoutTitleInput.value.length;
            }
            if (workoutDescriptionCharCount && workoutDescriptionInput) {
                workoutDescriptionCharCount.textContent = workoutDescriptionInput.value.length;
            }
            if (completionMessageCharCount && completionMessageInput) {
                completionMessageCharCount.textContent = completionMessageInput.value.length;
            }
        }
        
        // Workout title update
        workoutTitleInput.addEventListener('input', function() {
            updateCharCounts();
            updateWorkoutDisplay();
        });
        
        // Workout description update
        if (workoutDescriptionInput) {
            workoutDescriptionInput.addEventListener('input', function() {
                updateCharCounts();
                updateWorkoutDisplay();
            });
        }
        
        // Completion message update
        if (completionMessageInput) {
            completionMessageInput.addEventListener('input', function() {
                updateCharCounts();
            });
        }
        
        // Mobility workout select dropdown event listener
        workoutSelect.addEventListener('change', function() {
            primeSpeechForIOS();
            if (!isRunning || isPaused) {
                loadMobilityWorkout(this.value);
            }
        });
        
        // Prep phase handlers
        function syncPrepTimeFromInput() {
            const sec = parseTime(prepTimeInput && prepTimeInput.value);
            const s = Math.min(300, Math.max(0, sec));
            if (prepTimeSlider) prepTimeSlider.value = s;
            if (prepTimeInput) prepTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00');
            try { localStorage.setItem('mobility-prepTimeSeconds', String(s)); } catch (e) {}
            updateReminderDisplays();
        }
        function syncPrepTimeFromSlider() {
            const s = parseInt(prepTimeSlider && prepTimeSlider.value || 0, 10);
            if (prepTimeInput) prepTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00');
            try { localStorage.setItem('mobility-prepTimeSeconds', String(s)); } catch (e) {}
            updateReminderDisplays();
        }
        if (prepTimeInput) prepTimeInput.addEventListener('input', syncPrepTimeFromInput);
        if (prepTimeSlider) prepTimeSlider.addEventListener('input', syncPrepTimeFromSlider);
        if (prepTimeDecreaseBtn) prepTimeDecreaseBtn.addEventListener('click', function() {
            const sec = readPrepTimeFromInput();
            const s = Math.max(0, sec - 10);
            if (prepTimeInput) prepTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00');
            if (prepTimeSlider) prepTimeSlider.value = s;
            syncPrepTimeFromInput();
        });
        if (prepTimeIncreaseBtn) prepTimeIncreaseBtn.addEventListener('click', function() {
            const sec = readPrepTimeFromInput();
            const s = Math.min(300, sec + 10);
            if (prepTimeInput) prepTimeInput.value = s >= 60 ? formatTime(s) : (s > 0 ? String(s) : '00:00');
            if (prepTimeSlider) prepTimeSlider.value = s;
            syncPrepTimeFromInput();
        });
        if (prepPhaseLabelInput) prepPhaseLabelInput.addEventListener('change', function() {
            try { localStorage.setItem('mobility-prepPhaseLabel', this.value || 'Countdown'); } catch (e) {}
        });
        
        // Event listeners
        startBtn.addEventListener('click', function() {
            primeSpeechForIOS();
            if (isPaused) {
                resumeTimer();
            } else {
                ensureToneStarted().then(function() {
                    if (isIOS() && enableTonesEl && enableTonesEl.checked) playBeepShort();
                    startTimer();
                });
            }
        });
        
        pauseBtn.addEventListener('click', pauseTimer);
        completeNextBtn.addEventListener('click', completeNextRound);
        repeatWorkoutBtn.addEventListener('click', repeatWorkout);
        resetBtn.addEventListener('click', resetTimer);
        clearBtn.addEventListener('click', clearTimer);
        setupBtn.addEventListener('click', openSheet);
        addRoundGroupBtn.addEventListener('click', addRoundGroup);
        var drawerCloseBtnEl = document.getElementById('drawerCloseBtn');
        var drawerOverlayEl = document.getElementById('drawerOverlay');
        if (drawerCloseBtnEl) drawerCloseBtnEl.addEventListener('click', window.closeDrawer);
        if (drawerOverlayEl) drawerOverlayEl.addEventListener('click', window.closeDrawer);
        var timerDisplayBlockEl = document.getElementById('timerDisplayBlock');
        if (timerDisplayBlockEl) {
            timerDisplayBlockEl.addEventListener('click', openSheet);
            timerDisplayBlockEl.addEventListener('touchend', function(e) { e.preventDefault(); openSheet(); }, { passive: false });
        }
        var menuBtnEl = document.getElementById('menuBtn');
        if (menuBtnEl) menuBtnEl.addEventListener('click', window.toggleDrawer);
        function confirmClearSettings() {
            return confirm('Clear timer and reset all settings to defaults? Workout, title, notes, round groups, and completion message will be reset.');
        }
        var headerClearBtnEl = document.getElementById('headerClearBtn');
        var clearAllSettingsBtnEl = document.getElementById('clearAllSettingsBtn');
        if (headerClearBtnEl) {
            headerClearBtnEl.addEventListener('click', function() {
                if (confirmClearSettings()) clearTimer();
            });
        }
        if (clearAllSettingsBtnEl) {
            clearAllSettingsBtnEl.addEventListener('click', function() {
                if (confirmClearSettings()) clearTimer();
            });
        }
        exportBtn.addEventListener('click', exportWorkout);
        importBtn.addEventListener('click', importWorkout);
        
        // Make functions global for onclick handlers
        window.addActivity = addActivity;
        window.removeActivity = removeActivity;
        window.removeRoundGroup = removeRoundGroup;
        
        // Initialize
        updateCharCounts();
        updateWorkoutDisplay();
        updateReminderDisplays();
        updateButtonStates();
        updateDisplay();
        
        if (isIOS()) {
            const iosBanner = document.getElementById('iosSoundBanner');
            if (iosBanner && !audioStarted) { iosBanner.classList.remove('hidden'); iosBanner.style.display = ''; }
            const iosUnlockBtn = document.getElementById('iosUnlockSoundBtn');
            if (iosUnlockBtn) iosUnlockBtn.addEventListener('click', function() { unlockAudioForIOS(); });
            const iosSilentBtn = document.getElementById('iosSilentBtn');
            if (iosSilentBtn) iosSilentBtn.addEventListener('click', function() { dismissIOSSoundBannerSilent(); });
        }
        
        // Set release date
        document.getElementById('releaseDate').textContent = new Date().toISOString().split('T')[0];
    </script>
    <script>
        (function() {
            var themeKey = 'timerist-theme';
            var darkThemeValue = 'style1';
            function getInitialTheme() {
                var saved = localStorage.getItem(themeKey);
                if (saved) return saved;
                return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }
            function isDarkMode() {
                return document.documentElement.getAttribute('data-theme') === darkThemeValue;
            }
            function applyTheme(theme) {
                var root = document.documentElement;
                if (theme === 'dark') {
                    root.setAttribute('data-theme', darkThemeValue);
                } else {
                    root.removeAttribute('data-theme');
                }
                localStorage.setItem(themeKey, theme);
            }
            applyTheme(getInitialTheme());
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
                if (!localStorage.getItem(themeKey)) applyTheme(e.matches ? 'dark' : 'light');
            });
            window.toggleTheme = function() {
                applyTheme(isDarkMode() ? 'light' : 'dark');
            };
        })();
    </script>
    <script>
        // Ensure theme toggle button works on mobile (iOS/Android)
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.toggleTheme) {
                        window.toggleTheme();
                    }
                });
                
                themeToggleBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.toggleTheme) {
                        window.toggleTheme();
                    }
                }, { passive: false });
            }
        });
        
        // Logo color update for dark mode
        function updateLogoColors() {
            const logo = document.getElementById('timerist-logo');
            if (!logo) return;
            
            const isDark = document.documentElement.getAttribute('data-theme') === 'style1';
            const lightColor = '#0a0a0a';
            const darkColor = '#fafafa';
            const color = isDark ? darkColor : lightColor;
            
            const circles = logo.querySelectorAll('.logo-circle');
            const lines = logo.querySelectorAll('.logo-line');
            
            circles.forEach(el => el.setAttribute('stroke', color));
            lines.forEach(el => el.setAttribute('stroke', color));
        }
        
        // Theme icon update
        function updateThemeIcon() {
            const icon = document.getElementById('theme-icon');
            if (!icon) return;
            const isDark = document.documentElement.getAttribute('data-theme') === 'style1';
            icon.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
        }
        
        // Watch for theme changes
        const themeObserver = new MutationObserver(() => {
            updateLogoColors();
            updateThemeIcon();
        });
        themeObserver.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['data-theme', 'class']
        });
        
        // Override toggleTheme to update logo, icon
        const originalToggle = window.toggleTheme;
        if (originalToggle) {
            window.toggleTheme = function() {
                originalToggle();
                setTimeout(() => {
                    updateLogoColors();
                    updateThemeIcon();
                }, 10);
            };
        }
        
        updateLogoColors();
        updateThemeIcon();
    </script>
</body>
</html>
